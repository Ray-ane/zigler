/**
 * Ornstein-Uhlenbeck Process Forecasting for Bond Error and Z-Spread Differences
 * 
 * See README.md for detailed documentation and usage instructions.
 */

"use strict";
import "./../style/visual.less";
import * as d3 from "d3";
import powerbiVisualsApi from "powerbi-visuals-api";
import IVisual = powerbiVisualsApi.extensibility.visual.IVisual;
import VisualConstructorOptions = powerbiVisualsApi.extensibility.visual.VisualConstructorOptions;
import VisualUpdateOptions = powerbiVisualsApi.extensibility.visual.VisualUpdateOptions;
import DataView = powerbiVisualsApi.DataView;

// Constants
const CHART_MARGINS = { top: 50, right: 40, bottom: 120, left: 70 };
const CHART_SPACING = 50; // Increased spacing between charts
const FORECAST_STEPS = 30;
const ADF_THRESHOLD = -3;
const DEFAULT_LAMBDA = 1.0;
const DEFAULT_SIGMA = 1.0;

/**
 * Interface representing a single row of input data
 */
interface DataRow {
    inputdate: Date;
    context1: string;
    isin1: string;
    isin2: string;
    bond1: string;
    bond2: string;
    error: number;
    zspread: number; // Raw zspread values
}

/**
 * Interface for the difference series points
 */
interface DiffPoint {
    inputdate: Date;
    diff: number;                // error difference
    errorChange: number;         // daily change in error difference
    zspreadRaw1: number;         // raw zspread for bond1
    zspreadRaw2: number;         // raw zspread for bond2
    zspreadDiff: number;         // raw zspread difference
    zspreadChange: number;       // daily change in zspread difference
}

/**
 * Interface for OU process parameters and forecasts
 */
interface OUResults {
    lambda: number;
    mu: number;
    sigma: number;
    forecastPoints: DiffPoint[];
    upperBoundPoints: DiffPoint[];
    lowerBoundPoints: DiffPoint[];
}

/**
 * Memoization utility for expensive calculations
 * Stores previously computed results to avoid redundant calculations
 * by caching results based on input arguments
 */
function memoize<T, R>(fn: (arg: T) => R): (arg: T) => R {
    const cache = new Map<string, R>();
    return (arg: T) => {
        const key = JSON.stringify(arg);
        if (cache.has(key)) {
            return cache.get(key)!;
        }
        const result = fn(arg);
        cache.set(key, result);
        return result;
    };
}

export class Visual implements IVisual {
    // DOM Elements
    private target: HTMLElement;
    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;
    private dropdownPairs: HTMLSelectElement;
    private lambdaSlider: HTMLInputElement;
    private sigmaSlider: HTMLInputElement;

    // Data Storage
    private allData: DataRow[] = [];
    private diffSeries: DiffPoint[] = [];

    // Ornstein-Uhlenbeck Parameters
    private lambdaHat: number = 0;
    private muHat: number = 0;
    private sigmaHat: number = 0;
    private delta: number = 1;

    // Viewport Configuration
    private currentViewport: { width: number; height: number } = { width: 600, height: 300 };
    private diffSeriesStationary: boolean = false;
    private beta: number = 0;

    // Add cache for processed data
    private processedData: Map<string, DiffPoint[]> = new Map();

    constructor(options: VisualConstructorOptions) {
        this.initializeVisual(options);
    }

    /**
     * Initializes the visual with controls and event listeners
     */
    private initializeVisual(options: VisualConstructorOptions): void {
        this.target = options.element;
        
        // Clear completely before initializing
        this.target.innerHTML = "";
        
        // Build DOM in a more efficient order
        this.createControlContainer();
        this.createTooltip();
        this.createSVGContainer();
        this.initializeControls();
    }

    /**
     * Creates the control container with dropdown and sliders
     */
    private createControlContainer(): void {
        // Use document fragment for better performance
        const fragment = document.createDocumentFragment();
        const controlContainer = document.createElement("div");
        controlContainer.id = "control-container";
        
        // Create dropdown container
        const dropdownContainer = document.createElement("div");
        dropdownContainer.id = "dropdown-container";
        
        const dropdownLabel = document.createElement("label");
        dropdownLabel.setAttribute("for", "pairDropdown");
        dropdownLabel.textContent = "Select Pair (Bond1 vs Bond2):";
        
        this.dropdownPairs = document.createElement("select");
        this.dropdownPairs.id = "pairDropdown";
        this.dropdownPairs.style.fontSize = "10px";
        
        dropdownContainer.appendChild(dropdownLabel);
        dropdownContainer.appendChild(this.dropdownPairs);
        
        // Create slider container
        const sliderContainer = document.createElement("div");
        sliderContainer.id = "slider-container";
        
        // Lambda slider
        const lambdaContainer = document.createElement("div");
        const lambdaLabel = document.createElement("label");
        lambdaLabel.setAttribute("for", "lambdaSlider");
        lambdaLabel.textContent = "Lambda Factor:";
        
        this.lambdaSlider = document.createElement("input");
        this.lambdaSlider.id = "lambdaSlider";
        this.lambdaSlider.type = "range";
        this.lambdaSlider.min = "0.1";
        this.lambdaSlider.max = "2.0";
        this.lambdaSlider.step = "0.01";
        this.lambdaSlider.value = DEFAULT_LAMBDA.toString();
        
        const lambdaValue = document.createElement("span");
        lambdaValue.id = "lambdaValue";
        lambdaValue.textContent = DEFAULT_LAMBDA.toString();
        
        lambdaContainer.appendChild(lambdaLabel);
        lambdaContainer.appendChild(this.lambdaSlider);
        lambdaContainer.appendChild(lambdaValue);
        
        // Sigma slider
        const sigmaContainer = document.createElement("div");
        const sigmaLabel = document.createElement("label");
        sigmaLabel.setAttribute("for", "sigmaSlider");
        sigmaLabel.textContent = "Sigma Factor:";
        
        this.sigmaSlider = document.createElement("input");
        this.sigmaSlider.id = "sigmaSlider";
        this.sigmaSlider.type = "range";
        this.sigmaSlider.min = "0.1";
        this.sigmaSlider.max = "1.5";
        this.sigmaSlider.step = "0.01";
        this.sigmaSlider.value = DEFAULT_SIGMA.toString();
        
        const sigmaValue = document.createElement("span");
        sigmaValue.id = "sigmaValue";
        sigmaValue.textContent = DEFAULT_SIGMA.toString();
        
        sigmaContainer.appendChild(sigmaLabel);
        sigmaContainer.appendChild(this.sigmaSlider);
        sigmaContainer.appendChild(sigmaValue);
        
        // Assemble slider container
        sliderContainer.appendChild(lambdaContainer);
        sliderContainer.appendChild(sigmaContainer);
        
        // Assemble final control container
        controlContainer.appendChild(dropdownContainer);
        controlContainer.appendChild(sliderContainer);
        fragment.appendChild(controlContainer);
        
        // Single DOM manipulation for better performance
        this.target.appendChild(fragment);

    }

    /**
     * Creates the tooltip element
     */
    private createTooltip(): void {
        const tooltip = document.createElement("div");
        tooltip.id = "tooltip";
        Object.assign(tooltip.style, {
            position: "absolute",
            padding: "8px",
            background: "rgba(255, 255, 255, 0.9)",
            border: "1px solid #ddd",
            borderRadius: "4px",
            pointerEvents: "none",
            fontSize: "12px",
            zIndex: "1000",
            opacity: "0"
        });
        this.target.appendChild(tooltip);
    }

    /**
     * Initializes control elements and event listeners with performance optimizations
     */
    private initializeControls(): void {
        // Use debounced event handlers to prevent excessive rendering
        const debounce = (fn: Function, delay: number) => {
            let timer: number | null = null;
            return (...args: any[]) => {
                if (timer) window.clearTimeout(timer);
                timer = window.setTimeout(() => fn(...args), delay);
            };
        };
        
        // Add event listeners with performance optimizations
        this.dropdownPairs.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
        
        // Use input event for real-time updates on sliders
        this.lambdaSlider.addEventListener("input", () => {
            (document.getElementById("lambdaValue") as HTMLElement).innerText = this.lambdaSlider.value;
        });
        
        // Use change event for rendering only when slider stops (better performance)
        this.lambdaSlider.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
        
        this.sigmaSlider.addEventListener("input", () => {
            (document.getElementById("sigmaValue") as HTMLElement).innerText = this.sigmaSlider.value;
        });
        
        this.sigmaSlider.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
    }

    /**
     * Creates the SVG container for the chart
     */
    private createSVGContainer(): void {
        this.svg = d3.select(this.target)
            .append("svg")
            .classed("ou-estimation-visual", true);
    }

    /**
     * Parses a single row of data with validation
     */
    private parseDataRow(row: any[]): DataRow | null {
        let dateVal: Date;
        if (row[0] instanceof Date) {
            dateVal = row[0];
        } else if (typeof row[0] === 'string') {
            dateVal = new Date(row[0]);
            if (isNaN(dateVal.getTime())) return null;
        } else if (typeof row[0] === 'number') {
            dateVal = new Date(row[0]);
        } else {
            return null;
        }
        
        const zspreadValue = parseFloat(String(row[8]));
        
        return {
            inputdate: dateVal,
            context1: row[1]?.toString() || "",
            isin1: row[2]?.toString() || "",
            isin2: row[3]?.toString() || "",
            bond1: row[4]?.toString() || "",
            bond2: row[5]?.toString() || "",
            error: +row[6],
            zspread: zspreadValue
        };
    }

    /**
     * Resets sliders to default values
     */
    private resetSliders(): void {
        this.lambdaSlider.value = DEFAULT_LAMBDA.toString();
        this.sigmaSlider.value = DEFAULT_SIGMA.toString();
    }

    public update(options: VisualUpdateOptions) {
        const dataView: DataView = options.dataViews?.[0];
        if (!dataView?.table) return;
        
        this.currentViewport = options.viewport || { width: 600, height: 300 };
        this.resetSliders();

        this.allData = dataView.table.rows
            .map(row => this.parseDataRow(row))
            .filter((row): row is DataRow => row !== null)
            .sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());

        this.updateDropdown();
        
        if (this.allData.length > 0) {
            this.updateChartsInner();
        }
    }

    /**
     * Updates the dropdown with the latest P_VALUE rows
     * 
     * This method filters the most recent P_VALUE entries and populates
     * the dropdown with unique bond pairs for selection
     */
    private updateDropdown(): void {
        const pValueRows = this.allData.filter(d => d.context1.trim().toUpperCase() === "P_VALUE");

        if (pValueRows.length === 0) {
            this.dropdownPairs.options.length = 0;
            this.svg.selectAll("*").remove();
            return;
        }

        const maxDate = d3.max(pValueRows, d => d.inputdate.getTime())!;
        const latestRows = pValueRows.filter(d => 
            d.inputdate.toDateString() === new Date(maxDate).toDateString()
        );

        const uniquePairs = Array.from(new Set(
            latestRows.map(row => `${row.bond1} vs ${row.bond2}`)
        ));

        this.dropdownPairs.options.length = 0;
        uniquePairs.forEach(pair => {
            const opt = document.createElement("option");
            opt.value = pair;
            opt.text = pair;
            opt.style.fontSize = "10px";
            this.dropdownPairs.appendChild(opt);
        });

        if (uniquePairs.length > 0) {
            this.dropdownPairs.value = uniquePairs[0];
        }
    }

    /**
     * Core method to update charts based on the selected bond pair
     */
    private updateChartsInner() {
        if (this.dropdownPairs.options.length === 0) return;
        
        const selectedPair = this.dropdownPairs.value;
        if (!selectedPair) return;
        
        const [selectedBond1, selectedBond2] = selectedPair.split(" vs ");
        this.diffSeries = [];
        
        const errorRows = this.allData.filter(d => 
            d.context1.trim().toUpperCase() === "ERROR" &&
            (d.bond1.trim() === selectedBond1.trim() || d.bond1.trim() === selectedBond2.trim())
        );

        const mapBond1 = new Map<string, {error: number, zspread: number}>();
        const mapBond2 = new Map<string, {error: number, zspread: number}>();
        
        errorRows.forEach(d => {
            const key = d.inputdate.toDateString();
            const value = { error: d.error, zspread: d.zspread };
            
            if (d.bond1.trim() === selectedBond1.trim()) {
                mapBond1.set(key, value);
            } else if (d.bond1.trim() === selectedBond2.trim()) {
                mapBond2.set(key, value);
            }
        });

        const commonDates = Array.from(mapBond1.keys()).filter(key => mapBond2.has(key));
        commonDates.sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
        
        for (let i = 0; i < commonDates.length; i++) {
            const key = commonDates[i];
            const val1 = mapBond1.get(key)!;
            const val2 = mapBond2.get(key)!;
            
            const errorDiff = val2.error - val1.error;
            const zspreadDiff = val2.zspread - val1.zspread;
            
            let errorChange = 0;
            let zspreadChange = 0;
            
            if (i > 0) {
                const prevKey = commonDates[i-1];
                const prevVal1 = mapBond1.get(prevKey)!;
                const prevVal2 = mapBond2.get(prevKey)!;
                const prevErrorDiff = prevVal2.error - prevVal1.error;
                const prevZspreadDiff = prevVal2.zspread - prevVal1.zspread;
                
                errorChange = errorDiff - prevErrorDiff;
                zspreadChange = zspreadDiff - prevZspreadDiff;
                
                if (i === 1) {
                    this.diffSeries[0].errorChange = 0;
                    this.diffSeries[0].zspreadChange = 0;
                }
            }
            
            this.diffSeries.push({
                inputdate: new Date(key),
                diff: errorDiff,
                errorChange: errorChange,
                zspreadRaw1: val1.zspread,
                zspreadRaw2: val2.zspread,
                zspreadDiff: zspreadDiff,
                zspreadChange: zspreadChange
            });
        }
        
        if (this.diffSeries.length < 2) {
            this.renderChart(false);
            return;
        }

        const { beta } = this.calculateBeta();
        this.beta = beta;

        const diffs = this.diffSeries.map(d => d.diff);
        this.diffSeriesStationary = this.performADFTest(diffs);
        
        this.renderChart(this.diffSeriesStationary);
    }

    /**
     * Calculates the beta coefficient for the relationship between 
     * daily changes in error differences and zspread differences
     */
    private calculateBeta(): { beta: number } {
        if (this.diffSeries.length < 2) return { beta: 0 };
        
        const points = this.diffSeries.slice(1);
        let sumProduct = 0;
        let sumErrorChangeSq = 0;
        
        points.forEach(point => {
            sumProduct += point.errorChange * point.zspreadChange;
            sumErrorChangeSq += point.errorChange * point.errorChange;
        });
        
        return { beta: Math.abs(sumErrorChangeSq) > 1e-10 ? sumProduct / sumErrorChangeSq : 0 };
    }

    private performADFTest = memoize((data: number[]): boolean => {
        if (data.length < 3) return false;
        
        const dX = data.slice(1).map((val, i) => val - data[i]);
        const lagX = data.slice(0, -1);
        const meanLag = d3.mean(lagX)!;
        const meanDX = d3.mean(dX)!;
        
        const num = dX.reduce((sum, val, i) => sum + (lagX[i] - meanLag) * (val - meanDX), 0);
        const den = lagX.reduce((sum, val) => sum + Math.pow(val - meanLag, 2), 0);
        const slope = num / den;
        const ssr = dX.reduce((sum, val, i) => sum + Math.pow(val - slope * lagX[i], 2), 0);
        const s2 = ssr / (dX.length - 2);
        const se = Math.sqrt(s2 / den);
        
        return slope / se < ADF_THRESHOLD;
    });

    private calculateOUParameters(diffValues: number[], dates: Date[]): OUResults {
        if (diffValues.length < 2) {
            return { lambda: 0, mu: 0, sigma: 0, forecastPoints: [], upperBoundPoints: [], lowerBoundPoints: [] };
        }
        
        const n = diffValues.length - 1;
        const diffMean = d3.mean(diffValues)!;
        const totalTimeSpan = dates[dates.length - 1].getTime() - dates[0].getTime();
        const delta = totalTimeSpan / n;
        const deltaDays = delta / (1000 * 60 * 60 * 24);
        
        const deviations = diffValues.map(val => val - diffMean);
        let num = 0;
        let den = 0;
        
        for (let i = 0; i < n; i++) {
            num += deviations[i+1] * deviations[i];
            den += deviations[i] * deviations[i];
        }
        
        const alphaHat = Math.max(Math.min(num / den, 0.9999999), -0.9999999);
        const lambdaHat = -Math.log(alphaHat) / deltaDays;
        
        let sumResidual = 0;
        for (let i = 0; i < n; i++) {
            sumResidual += diffValues[i+1] - alphaHat * diffValues[i];
        }
        const muHat = sumResidual / (n * (1 - alphaHat));

        let sumSq = 0;
        for (let i = 0; i < n; i++) {
            const r = diffValues[i+1] - alphaHat * diffValues[i] - (1 - alphaHat) * muHat;
            sumSq += r * r;
        }
        
        const sigmaSqHat = (2 * lambdaHat) / (1 - alphaHat * alphaHat) * (1 / n) * sumSq;
        const sigmaHat = Math.sqrt(Math.max(sigmaSqHat, 0));

        const lambdaFactor = parseFloat(this.lambdaSlider.value);
        const sigmaFactor = parseFloat(this.sigmaSlider.value);
        const newLambda = lambdaHat * lambdaFactor;
        const newSigma = sigmaHat * sigmaFactor;
        const alpha = Math.exp(-newLambda * deltaDays);

        const lastDiff = diffValues[diffValues.length - 1];
        const lastTime = dates[dates.length - 1].getTime();
        
        const forecastPoints: DiffPoint[] = [];
        const upperBoundPoints: DiffPoint[] = [];
        const lowerBoundPoints: DiffPoint[] = [];

        for (let i = 0; i <= FORECAST_STEPS; i++) {
            const nextDate = new Date(lastTime + i * delta);
            const alphaPow = Math.pow(alpha, i);
            const meanForecast = muHat + (lastDiff - muHat) * alphaPow;
            const varForecast = (newSigma * newSigma) / (2 * newLambda) * (1 - Math.pow(alpha, 2 * i));
            const stdDev = Math.sqrt(varForecast);
            
            const basePoint = {
                inputdate: nextDate,
                errorChange: 0,
                zspreadRaw1: 0,
                zspreadRaw2: 0,
                zspreadDiff: 0,
                zspreadChange: 0
            };
            
            forecastPoints.push({ ...basePoint, diff: meanForecast });
            upperBoundPoints.push({ ...basePoint, diff: meanForecast + 1.96 * stdDev });
            lowerBoundPoints.push({ ...basePoint, diff: meanForecast - 1.96 * stdDev });
        }

        return { lambda: newLambda, mu: muHat, sigma: newSigma, forecastPoints, upperBoundPoints, lowerBoundPoints };
    }

    private renderChart(isStationary: boolean) {
        const width = this.currentViewport.width;
        const height = this.currentViewport.height;
        const totalWidth = width - CHART_MARGINS.left - CHART_MARGINS.right;
        const chartWidth = (totalWidth - CHART_SPACING) / 2;
        const innerHeight = height - CHART_MARGINS.top - CHART_MARGINS.bottom;

        this.svg.selectAll("*").remove();
        this.svg.attr("width", width).attr("height", height);

        const errorChart = this.svg.append("g")
            .attr("transform", `translate(${CHART_MARGINS.left}, ${CHART_MARGINS.top})`);
        const zspreadChart = this.svg.append("g")
            .attr("transform", `translate(${CHART_MARGINS.left + chartWidth + CHART_SPACING}, ${CHART_MARGINS.top})`);

        if (this.diffSeries.length < 1) {
            this.renderEmptyChart(errorChart, chartWidth, innerHeight);
            return;
        }

        const { xScale, yScale } = this.createScales(isStationary, chartWidth, innerHeight);
        this.renderErrorChart(errorChart, xScale, yScale, chartWidth, innerHeight, isStationary);
        this.renderZspreadChart(zspreadChart, xScale, chartWidth, innerHeight);
    }

    private renderEmptyChart(g: d3.Selection<SVGGElement, unknown, null, undefined>, width: number, height: number) {
        g.append("text")
            .attr("x", width / 2)
            .attr("y", height / 2)
            .attr("text-anchor", "middle")
            .attr("fill", "red")
            .style("font-size", "14px")
            .text("No data to display.");
    }

    private createScales(isStationary: boolean, width: number, height: number) {
        let xScale: d3.ScaleTime<number, number>;
        let yScale: d3.ScaleLinear<number, number>;

        if (isStationary) {
            const ouResults = this.calculateOUParameters(
                this.diffSeries.map(d => d.diff),
                this.diffSeries.map(d => d.inputdate)
            );

            const allX = this.diffSeries.map(d => d.inputdate)
                .concat(ouResults.forecastPoints.map(d => d.inputdate));
            
            const allY = this.diffSeries.map(d => d.diff)
                .concat(ouResults.forecastPoints.map(d => d.diff))
                .concat(ouResults.upperBoundPoints.map(d => d.diff))
                .concat(ouResults.lowerBoundPoints.map(d => d.diff));

            xScale = d3.scaleTime()
                .domain([d3.min(allX) as Date, d3.max(allX) as Date])
                .range([0, width]);

            yScale = d3.scaleLinear()
                .domain([d3.min(allY) as number, d3.max(allY) as number])
                .range([height, 0])
                .nice();
        } else {
            xScale = d3.scaleTime()
                .domain([
                    d3.min(this.diffSeries, d => d.inputdate)!,
                    d3.max(this.diffSeries, d => d.inputdate)!
                ])
                .range([0, width]);

            yScale = d3.scaleLinear()
                .domain([
                    d3.min(this.diffSeries, d => d.diff) as number,
                    d3.max(this.diffSeries, d => d.diff) as number
                ])
                .range([height, 0])
                .nice();
        }

        return { xScale, yScale };
    }

    private renderErrorChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        width: number,
        height: number,
        isStationary: boolean
    ) {
        const lineGen = d3.line<DiffPoint>()
            .x(d => xScale(d.inputdate))
            .y(d => yScale(d.diff))
            .curve(d3.curveMonotoneX);

        if (isStationary) {
            const ouResults = this.calculateOUParameters(
                this.diffSeries.map(d => d.diff),
                this.diffSeries.map(d => d.inputdate)
            );

            g.append("path")
                .datum(ouResults.lowerBoundPoints)
                .attr("fill", "none")
                .attr("stroke", "grey")
                .attr("stroke-width", 1)
                .style("stroke-dasharray", "3,3")
                .attr("d", lineGen);

            g.append("path")
                .datum(ouResults.upperBoundPoints)
                .attr("fill", "none")
                .attr("stroke", "grey")
                .attr("stroke-width", 1)
                .style("stroke-dasharray", "3,3")
                .attr("d", lineGen);

            g.append("path")
                .datum(ouResults.forecastPoints)
                .attr("fill", "none")
                .attr("stroke", "orange")
                .attr("stroke-width", 2)
                .attr("d", lineGen);
        }

        g.append("path")
            .datum(this.diffSeries)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .attr("d", lineGen);

        this.addAxes(g, xScale, yScale, width, height);
    }

    private renderZspreadChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        width: number,
        height: number
    ) {
        const zspreadDiffData = this.diffSeries.map(d => ({
            inputdate: d.inputdate,
            value: d.zspreadDiff
        }));

        if (zspreadDiffData.length === 0) {
            this.renderEmptyChart(g, width, height);
            return;
        }

        const yScale = d3.scaleLinear()
            .domain([
                d3.min(zspreadDiffData, d => d.value) as number,
                d3.max(zspreadDiffData, d => d.value) as number
            ])
            .range([height, 0])
            .nice();

        const lineGen = d3.line<{inputdate: Date, value: number}>()
            .x(d => xScale(d.inputdate))
            .y(d => yScale(d.value))
            .curve(d3.curveMonotoneX);

        g.append("path")
            .datum(zspreadDiffData)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .attr("d", lineGen);

        this.addAxes(g, xScale, yScale, width, height);
    }

    private addAxes(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        width: number,
        height: number
    ) {
        const xAxis = d3.axisBottom(xScale)
            .ticks(Math.max(2, Math.floor(width / 100)))
            .tickFormat(d3.timeFormat("%b %d, %Y"));

        g.append("g")
            .attr("transform", `translate(0, ${height})`)
            .call(xAxis)
            .selectAll("text")
            .attr("transform", "rotate(-20)")
            .style("text-anchor", "end")
            .style("font-size", "10px");

        const yAxis = d3.axisLeft(yScale).ticks(5);
        g.append("g").call(yAxis);
    }
}
