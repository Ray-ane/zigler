/**
 * Ornstein-Uhlenbeck Process Forecasting for Bond Error and Z-Spread Differences
 * 
 * See README.md for detailed documentation and usage instructions.
 */

"use strict";
import "./../style/visual.less";
import * as d3 from "d3";
import powerbiVisualsApi from "powerbi-visuals-api";
import IVisual = powerbiVisualsApi.extensibility.visual.IVisual;
import VisualConstructorOptions = powerbiVisualsApi.extensibility.visual.VisualConstructorOptions;
import VisualUpdateOptions = powerbiVisualsApi.extensibility.visual.VisualUpdateOptions;
import DataView = powerbiVisualsApi.DataView;

// Constants
const CHART_MARGINS = { top: 50, right: 40, bottom: 120, left: 70 };
const CHART_SPACING = 50; // Increased spacing between charts
const FORECAST_STEPS = 30;
const ADF_THRESHOLD = -3;
const DEFAULT_LAMBDA = 1.0;
const DEFAULT_SIGMA = 1.0;

/**
 * Interface representing a single row of input data
 */
interface DataRow {
    inputdate: Date;
    context1: string;
    isin1: string;
    isin2: string;
    bond1: string;
    bond2: string;
    error: number;
    zspread: number; // Raw zspread values
}

/**
 * Interface for the difference series points
 */
interface DiffPoint {
    inputdate: Date;
    diff: number;                // error difference
    errorChange: number;         // daily change in error difference
    zspreadRaw1: number;         // raw zspread for bond1
    zspreadRaw2: number;         // raw zspread for bond2
    zspreadDiff: number;         // raw zspread difference
    zspreadChange: number;       // daily change in zspread difference
}

/**
 * Interface for OU process parameters and forecasts
 */
interface OUResults {
    lambda: number;
    mu: number;
    sigma: number;
    forecastPoints: DiffPoint[];
    upperBoundPoints: DiffPoint[];
    lowerBoundPoints: DiffPoint[];
}

/**
 * Memoization utility for expensive calculations
 * Stores previously computed results to avoid redundant calculations
 * by caching results based on input arguments
 */
function memoize<T, R>(fn: (arg: T) => R): (arg: T) => R {
    const cache = new Map<string, R>();
    return (arg: T) => {
        const key = JSON.stringify(arg);
        if (cache.has(key)) {
            return cache.get(key)!;
        }
        const result = fn(arg);
        cache.set(key, result);
        return result;
    };
}

export class Visual implements IVisual {
    // DOM Elements
    private target: HTMLElement;
    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;
    private dropdownPairs: HTMLSelectElement;
    private lambdaSlider: HTMLInputElement;
    private sigmaSlider: HTMLInputElement;

    // Data Storage
    private allData: DataRow[] = [];
    private diffSeries: DiffPoint[] = [];

    // Ornstein-Uhlenbeck Parameters
    private lambdaHat: number = 0;
    private muHat: number = 0;
    private sigmaHat: number = 0;
    private delta: number = 1;

    // Viewport Configuration
    private currentViewport: { width: number; height: number } = { width: 600, height: 300 };
    private diffSeriesStationary: boolean = false;
    private beta: number = 0;

    // Add cache for processed data
    private processedData: Map<string, DiffPoint[]> = new Map();

    constructor(options: VisualConstructorOptions) {
        this.initializeVisual(options);
    }

    /**
     * Initializes the visual with controls and event listeners
     */
    private initializeVisual(options: VisualConstructorOptions): void {
        this.target = options.element;
        
        // Clear completely before initializing
        this.target.innerHTML = "";
        
        // Build DOM in a more efficient order
        this.createControlContainer();
        this.createTooltip();
        this.createSVGContainer();
        this.initializeControls();
    }

    /**
     * Creates the control container with dropdown and sliders
     */
    private createControlContainer(): void {
        // Use document fragment for better performance
        const fragment = document.createDocumentFragment();
        const controlContainer = document.createElement("div");
        controlContainer.id = "control-container";
        
        // Create dropdown container
        const dropdownContainer = document.createElement("div");
        dropdownContainer.id = "dropdown-container";
        
        const dropdownLabel = document.createElement("label");
        dropdownLabel.setAttribute("for", "pairDropdown");
        dropdownLabel.textContent = "Select Pair (Bond1 vs Bond2):";
        
        this.dropdownPairs = document.createElement("select");
        this.dropdownPairs.id = "pairDropdown";
        this.dropdownPairs.style.fontSize = "10px";
        
        dropdownContainer.appendChild(dropdownLabel);
        dropdownContainer.appendChild(this.dropdownPairs);
        
        // Create slider container
        const sliderContainer = document.createElement("div");
        sliderContainer.id = "slider-container";
        
        // Lambda slider
        const lambdaContainer = document.createElement("div");
        const lambdaLabel = document.createElement("label");
        lambdaLabel.setAttribute("for", "lambdaSlider");
        lambdaLabel.textContent = "Lambda Factor:";
        
        this.lambdaSlider = document.createElement("input");
        this.lambdaSlider.id = "lambdaSlider";
        this.lambdaSlider.type = "range";
        this.lambdaSlider.min = "0.1";
        this.lambdaSlider.max = "2.0";
        this.lambdaSlider.step = "0.01";
        this.lambdaSlider.value = DEFAULT_LAMBDA.toString();
        
        const lambdaValue = document.createElement("span");
        lambdaValue.id = "lambdaValue";
        lambdaValue.textContent = DEFAULT_LAMBDA.toString();
        
        lambdaContainer.appendChild(lambdaLabel);
        lambdaContainer.appendChild(this.lambdaSlider);
        lambdaContainer.appendChild(lambdaValue);
        
        // Sigma slider
        const sigmaContainer = document.createElement("div");
        const sigmaLabel = document.createElement("label");
        sigmaLabel.setAttribute("for", "sigmaSlider");
        sigmaLabel.textContent = "Sigma Factor:";
        
        this.sigmaSlider = document.createElement("input");
        this.sigmaSlider.id = "sigmaSlider";
        this.sigmaSlider.type = "range";
        this.sigmaSlider.min = "0.1";
        this.sigmaSlider.max = "1.5";
        this.sigmaSlider.step = "0.01";
        this.sigmaSlider.value = DEFAULT_SIGMA.toString();
        
        const sigmaValue = document.createElement("span");
        sigmaValue.id = "sigmaValue";
        sigmaValue.textContent = DEFAULT_SIGMA.toString();
        
        sigmaContainer.appendChild(sigmaLabel);
        sigmaContainer.appendChild(this.sigmaSlider);
        sigmaContainer.appendChild(sigmaValue);
        
        // Assemble slider container
        sliderContainer.appendChild(lambdaContainer);
        sliderContainer.appendChild(sigmaContainer);
        
        // Assemble final control container
        controlContainer.appendChild(dropdownContainer);
        controlContainer.appendChild(sliderContainer);
        fragment.appendChild(controlContainer);
        
        // Single DOM manipulation for better performance
        this.target.appendChild(fragment);
    }

    /**
     * Creates the tooltip element
     */
    private createTooltip(): void {
        const tooltip = document.createElement("div");
        tooltip.id = "tooltip";
        Object.assign(tooltip.style, {
            position: "absolute",
            padding: "8px",
            background: "rgba(255, 255, 255, 0.9)",
            border: "1px solid #ddd",
            borderRadius: "4px",
            pointerEvents: "none",
            fontSize: "12px",
            zIndex: "1000",
            opacity: "0"
        });
        this.target.appendChild(tooltip);
    }

    /**
     * Initializes control elements and event listeners with performance optimizations
     */
    private initializeControls(): void {
        // Use debounced event handlers to prevent excessive rendering
        const debounce = (fn: Function, delay: number) => {
            let timer: number | null = null;
            return (...args: any[]) => {
                if (timer) window.clearTimeout(timer);
                timer = window.setTimeout(() => fn(...args), delay);
            };
        };
        
        // Add event listeners with performance optimizations
        this.dropdownPairs.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
        
        // Use input event for real-time updates on sliders
        this.lambdaSlider.addEventListener("input", () => {
            (document.getElementById("lambdaValue") as HTMLElement).innerText = this.lambdaSlider.value;
        });
        
        // Use change event for rendering only when slider stops (better performance)
        this.lambdaSlider.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
        
        this.sigmaSlider.addEventListener("input", () => {
            (document.getElementById("sigmaValue") as HTMLElement).innerText = this.sigmaSlider.value;
        });
        
        this.sigmaSlider.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
    }

    /**
     * Creates the SVG container for the chart
     */
    private createSVGContainer(): void {
        this.svg = d3.select(this.target)
            .append("svg")
            .classed("ou-estimation-visual", true);
    }

    /**
     * Parses a single row of data with validation
     */
    private parseDataRow(row: any[]): DataRow | null {
        let dateVal: Date;
        if (row[0] instanceof Date) {
            dateVal = row[0];
        } else if (typeof row[0] === 'string') {
            dateVal = new Date(row[0]);
            if (isNaN(dateVal.getTime())) return null;
        } else if (typeof row[0] === 'number') {
            dateVal = new Date(row[0]);
        } else {
            return null;
        }
        
        // DEBUG: Log the entire row to check all available values
        console.log(`DEBUG: Full row data:`, row);

        // Log values to determine which column contains the zspread data
        console.log(`Checking possible zspread columns:
            Column 7: ${row[7]}
            Column 8: ${row[8]}
            Column 9: ${row[9]}
            Column 10: ${row[10]}
        `);
        
        // Try to detect which column actually contains zspread data
        let zspreadValue = 0;
        let zspreadColumn = 8; // Default column
        
        // Check if column 7 might contain the zspread value
        if (row[7] !== undefined && row[7] !== null && !isNaN(parseFloat(String(row[7])))) {
            zspreadValue = parseFloat(String(row[7]));
            zspreadColumn = 7;
            console.log(`Using column 7 for zspread: ${zspreadValue}`);
        } 
        // If not, try column 8
        else if (row[8] !== undefined && row[8] !== null && !isNaN(parseFloat(String(row[8])))) {
            zspreadValue = parseFloat(String(row[8]));
            console.log(`Using column 8 for zspread: ${zspreadValue}`);
        }
        // If not, try column 9
        else if (row[9] !== undefined && row[9] !== null && !isNaN(parseFloat(String(row[9])))) {
            zspreadValue = parseFloat(String(row[9]));
            zspreadColumn = 9;
            console.log(`Using column 9 for zspread: ${zspreadValue}`);
        }
        
        return {
            inputdate: dateVal,
            context1: row[1]?.toString() || "",
            isin1: row[2]?.toString() || "",
            isin2: row[3]?.toString() || "",
            bond1: row[4]?.toString() || "",
            bond2: row[5]?.toString() || "",
            error: +row[6],
            zspread: zspreadValue // Use the detected zspread value
        };
    }

    /**
     * Resets sliders to default values
     */
    private resetSliders(): void {
        this.lambdaSlider.value = DEFAULT_LAMBDA.toString();
        this.sigmaSlider.value = DEFAULT_SIGMA.toString();
        (document.getElementById("lambdaValue") as HTMLElement).innerText = DEFAULT_LAMBDA.toString();
        (document.getElementById("sigmaValue") as HTMLElement).innerText = DEFAULT_SIGMA.toString();
    }

    public update(options: VisualUpdateOptions) {
        const dataView: DataView = options.dataViews?.[0];
        if (!dataView?.table) return;
        
        this.currentViewport = options.viewport || { width: 600, height: 300 };
        this.resetSliders();

        const rows = dataView.table.rows;
        if (!rows?.length) return;

        // Parse and sort data
        this.allData = rows
            .map(row => this.parseDataRow(row))
            .filter((row): row is DataRow => row !== null)
            .sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());

        // Update dropdown with latest P_VALUE rows
        this.updateDropdown();
        
        // Update chart if data is available
        if (this.allData.length > 0) {
            this.updateChartsInner();
        }
    }

    /**
     * Updates the dropdown with the latest P_VALUE rows
     * 
     * This method filters the most recent P_VALUE entries and populates
     * the dropdown with unique bond pairs for selection
     */
    private updateDropdown(): void {
        // Filter rows with context1 = "P_VALUE"
        const pValueRows = this.allData.filter(d => 
            d.context1.trim().toUpperCase() === "P_VALUE"
        );

        if (pValueRows.length === 0) {
            this.dropdownPairs.options.length = 0;
            this.svg.selectAll("*").remove();
            return;
        }

        // Find the most recent date in the P_VALUE rows
        const maxDate = d3.max(pValueRows, d => d.inputdate.getTime())!;
        const latestRows = pValueRows.filter(d => 
            d.inputdate.toDateString() === new Date(maxDate).toDateString()
        );

        const uniquePairs = Array.from(new Set(
            latestRows.map(row => `${row.bond1} vs ${row.bond2}`)
        ));

        this.dropdownPairs.options.length = 0;
        uniquePairs.forEach(pair => {
            const opt = document.createElement("option");
            opt.value = pair;
            opt.text = pair;
            opt.style.fontSize = "10px";
            this.dropdownPairs.appendChild(opt);
        });

        if (uniquePairs.length > 0) {
            this.dropdownPairs.value = uniquePairs[0];
        }
    }

    /**
     * Core method to update charts based on the selected bond pair
     */
    private updateChartsInner() {
        console.log("===== CALCULATING DIFFERENCES AND CHANGES =====");
        
        if (this.dropdownPairs.options.length === 0) return;
        
        const selectedPair = this.dropdownPairs.value;
        if (!selectedPair) return;
        
        const [selectedBond1, selectedBond2] = selectedPair.split(" vs ");
        console.log(`Selected pair: ${selectedBond1} vs ${selectedBond2}`);

        // Clear previous data
        this.diffSeries = [];
        
        // Filter and compute difference series for both error and zspread
        const errorRows = this.allData.filter(d => 
            d.context1.trim().toUpperCase() === "ERROR" &&
            (d.bond1.trim() === selectedBond1.trim() || d.bond1.trim() === selectedBond2.trim())
        );

        console.log(`Found ${errorRows.length} error rows for the selected bonds`);
        
        // DEBUG: Check raw zspread values in the filtered rows
        console.log("DEBUG: Sample of raw data rows with zspread values:");
        errorRows.slice(0, 5).forEach(row => {
            console.log(`Bond: ${row.bond1}, Date: ${row.inputdate.toLocaleDateString()}, Error: ${row.error}, ZSpread: ${row.zspread}`);
        });

        const mapBond1 = new Map<string, {error: number, zspread: number}>();
        const mapBond2 = new Map<string, {error: number, zspread: number}>();
        
        errorRows.forEach(d => {
            const key = d.inputdate.toDateString();
            const value = { 
                error: d.error, 
                zspread: d.zspread
            };
            
            if (d.bond1.trim() === selectedBond1.trim()) {
                mapBond1.set(key, value);
            } else if (d.bond1.trim() === selectedBond2.trim()) {
                mapBond2.set(key, value);
            }
        });

        // DEBUG: Check values in the maps
        console.log("DEBUG: Sample values from Bond1 map:");
        let count = 0;
        mapBond1.forEach((value, key) => {
            if (count < 5) {
                console.log(`Date: ${key}, Error: ${value.error}, ZSpread: ${value.zspread}`);
                count++;
            }
        });
        
        console.log("DEBUG: Sample values from Bond2 map:");
        count = 0;
        mapBond2.forEach((value, key) => {
            if (count < 5) {
                console.log(`Date: ${key}, Error: ${value.error}, ZSpread: ${value.zspread}`);
                count++;
            }
        });

        console.log(`Bond1 data points: ${mapBond1.size}, Bond2 data points: ${mapBond2.size}`);

        // Collect dates where both bonds have data
        const commonDates: string[] = [];
        mapBond1.forEach((_, key) => {
            if (mapBond2.has(key)) {
                commonDates.push(key);
            }
        });
        
        // Sort dates chronologically
        commonDates.sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
        console.log(`Found ${commonDates.length} days with data for both bonds`);
        
        // Create diffSeries with differences and daily changes
        console.log("COMPUTING ERROR AND ZSPREAD DIFFERENCES AND DAILY CHANGES:");
        
        for (let i = 0; i < commonDates.length; i++) {
            const key = commonDates[i];
            const val1 = mapBond1.get(key)!;
            const val2 = mapBond2.get(key)!;
            
            // DEBUG: Log raw values being used for difference calculation
            console.log(`DEBUG: Raw values for ${key}:`);
            console.log(`  Bond1: error=${val1.error}, zspread=${val1.zspread}`);
            console.log(`  Bond2: error=${val2.error}, zspread=${val2.zspread}`);
            
            // Calculate differences for current day
            const errorDiff = val2.error - val1.error;
            const zspreadDiff = val2.zspread - val1.zspread;
            
            console.log(`${key}: errorDiff = ${errorDiff}, zspreadDiff = ${zspreadDiff}`);
            
            // Initialize daily changes (will be set in next loop iteration if not the first point)
            let errorChange = 0;
            let zspreadChange = 0;
            
            // For points beyond the first one, calculate daily changes
            if (i > 0) {
                const prevKey = commonDates[i-1];
                const prevVal1 = mapBond1.get(prevKey)!;
                const prevVal2 = mapBond2.get(prevKey)!;
                const prevErrorDiff = prevVal2.error - prevVal1.error;
                const prevZspreadDiff = prevVal2.zspread - prevVal1.zspread;
                
                errorChange = errorDiff - prevErrorDiff;
                zspreadChange = zspreadDiff - prevZspreadDiff;
                
                console.log(`  Daily change: errorChange = ${errorChange}, zspreadChange = ${zspreadChange}`);
                
                // Update previous point's change values since we now know them
                if (i === 1) {
                    // For the first point, set changes to 0
                    this.diffSeries[0].errorChange = 0;
                    this.diffSeries[0].zspreadChange = 0;
                }
            }
            
            // Add the current point
            this.diffSeries.push({
                inputdate: new Date(key),
                diff: errorDiff,
                errorChange: errorChange,
                zspreadRaw1: val1.zspread,
                zspreadRaw2: val2.zspread,
                zspreadDiff: zspreadDiff,
                zspreadChange: zspreadChange
            });
        }
        
        console.log(`Built diffSeries with ${this.diffSeries.length} points`);
        
        if (this.diffSeries.length < 2) {
            console.log("Not enough points to calculate beta or render charts");
            this.renderChart(false);
            return;
        }

        // Calculate beta coefficient
        const { beta } = this.calculateBeta();
        this.beta = beta;

        // Apply ADF test to check for stationarity of error_diff
        const diffs = this.diffSeries.map(d => d.diff);
        this.diffSeriesStationary = this.performADFTest(diffs);
        
        console.log(`Series stationary: ${this.diffSeriesStationary}, Beta: ${beta}`);
        console.log("===========================================");
        
        this.renderChart(this.diffSeriesStationary);
    }

    /**
     * Calculates the beta coefficient for the relationship between 
     * daily changes in error differences and zspread differences
     */
    private calculateBeta(): { beta: number } {
        console.log("===== SIMPLE BETA CALCULATION =====");
        
        // Check if we have enough data points
        if (this.diffSeries.length < 2) {
            console.log("Not enough data points for beta calculation");
            return { beta: 0 };
        }
        
        // Skip the first point which doesn't have change values
        const points = this.diffSeries.slice(1);
        
        // Log all the change data points clearly
        console.log("RAW DATA POINTS (error_diff_change and zspread_diff_change):");
        points.forEach((point, i) => {
            console.log(`Point ${i+1}: error_diff_change = ${point.errorChange}, zspread_diff_change = ${point.zspreadChange}, date = ${point.inputdate.toLocaleDateString()}`);
        });
        
        // Calculate sum of errorChange * zspreadChange and sum of errorChange^2
        let sumProduct = 0;
        let sumErrorChangeSq = 0;
        
        // Simplest form of beta calculation: sum(xy)/sum(x^2)
        points.forEach(point => {
            sumProduct += point.errorChange * point.zspreadChange;
            sumErrorChangeSq += point.errorChange * point.errorChange;
        });
        
        console.log("SUMS:");
        console.log(`Sum of products: ${sumProduct}`);
        console.log(`Sum of error change squared: ${sumErrorChangeSq}`);
        
        // Calculate beta
        let beta = 0;
        if (Math.abs(sumErrorChangeSq) > 1e-10) {
            beta = sumProduct / sumErrorChangeSq;
        }
        
        console.log(`BETA = ${beta}`);
        console.log("=====================================");
        
        return { beta };
    }

    // Update the ADF test implementation with better comments
    private performADFTest = memoize((data: number[]): boolean => {
        if (data.length < 3) return false;
        
        // ADF test equation: Δy_t = α + βy_{t-1} + ε_t
        // where β = ρ - 1 and ρ is the autoregressive coefficient
        
        // Create first difference series (Δy_t)
        const dX = data.slice(1).map((val, i) => val - data[i]);
        // Create lagged series (y_{t-1})
        const lagX = data.slice(0, -1);
        
        // Calculate means for demeaning
        const meanLag = d3.mean(lagX)!;
        const meanDX = d3.mean(dX)!;
        
        // Calculate numerator for the slope coefficient: Σ(y_{t-1} - mean_y)(Δy_t - mean_Δy)
        const num = dX.reduce((sum, val, i) => 
            sum + (lagX[i] - meanLag) * (val - meanDX), 0);
        // Calculate denominator: Σ(y_{t-1} - mean_y)²
        const den = lagX.reduce((sum, val) => 
            sum + Math.pow(val - meanLag, 2), 0);
            
        // Calculate slope coefficient β
        const slope = num / den;
        
        // Calculate sum of squared residuals for standard error
        const ssr = dX.reduce((sum, val, i) => 
            sum + Math.pow(val - slope * lagX[i], 2), 0);
            
        // Calculate variance of residuals
        const s2 = ssr / (dX.length - 2);
        // Calculate standard error of slope coefficient
        const se = Math.sqrt(s2 / den);
        // Calculate t-statistic (Dickey-Fuller test statistic)
        const tStat = slope / se;
        
        // Compare against critical value ADF_THRESHOLD (typically -3)
        // If t-statistic < threshold, reject null hypothesis of unit root (non-stationarity)
        return tStat < ADF_THRESHOLD;
    });

    // Add detailed comments to OU parameter estimation
    private calculateOUParameters(diffValues: number[], dates: Date[]): OUResults {
        // Only compute when we have enough data
        if (diffValues.length < 2) {
            return {
                lambda: 0,
                mu: 0,
                sigma: 0,
                forecastPoints: [],
                upperBoundPoints: [],
                lowerBoundPoints: []
            };
        }
        
        const n = diffValues.length - 1;
        // Calculate long-term mean (μ) estimate
        const diffMean = d3.mean(diffValues)!;
        
        // Calculate time parameters
        // Total time span in milliseconds
        const totalTimeSpan = (dates[dates.length - 1].getTime() - dates[0].getTime());
        // Average time step between observations
        const delta = totalTimeSpan / n;
        // Convert to days for more intuitive lambda parameter
        const deltaDays = delta / (1000 * 60 * 60 * 24);
        
        // Precalculate deviations to avoid repeated calculations
        const deviations = diffValues.map(val => val - diffMean);
        
        // Calculate auto-correlation coefficient (α) using demeaned values
        // In OU process, α = e^(-λΔt) where Δt is time step
        let num = 0;
        let den = 0;
        for (let i = 0; i < n; i++) {
            num += deviations[i+1] * deviations[i];  // Covariance between X_t and X_{t+1}
            den += deviations[i] * deviations[i];    // Variance of X_t
        }
        // Bound alpha to prevent numerical issues
        let alphaHat = Math.max(Math.min(num / den, 0.9999999), -0.9999999);

        // Calculate mean reversion rate (λ)
        // From α = e^(-λΔt), we get λ = -ln(α)/Δt
        const lambdaHat = -Math.log(alphaHat) / deltaDays;
        
        // Calculate long-term mean (μ) using residuals
        // For OU process discrete form: X_{t+1} = μ(1-α) + αX_t + ε_t
        // Rearranging: X_{t+1} - αX_t = μ(1-α) + ε_t
        let sumResidual = 0;
        for (let i = 0; i < n; i++) {
            sumResidual += diffValues[i+1] - alphaHat * diffValues[i];
        }
        const muHat = sumResidual / (n * (1 - alphaHat));

        // Calculate volatility (σ) using residuals from the model
        // ε_t = X_{t+1} - μ(1-α) - αX_t
        let sumSq = 0;
        for (let i = 0; i < n; i++) {
            const r = diffValues[i+1] - alphaHat * diffValues[i] - (1 - alphaHat) * muHat;
            sumSq += r * r;
        }
        // Using relationship between discrete and continuous time parameters
        // σ²_continuous = 2λσ²_discrete/(1-α²) where σ²_discrete = Var(ε_t)
        const sigmaSqHat = (2 * lambdaHat) / (1 - alphaHat * alphaHat) * (1 / n) * sumSq;
        const sigmaHat = Math.sqrt(Math.max(sigmaSqHat, 0));

        // Apply user-adjustable scaling factors for sensitivity analysis
        const lambdaFactor = parseFloat(this.lambdaSlider.value);
        const sigmaFactor = parseFloat(this.sigmaSlider.value);
        const newLambda = lambdaHat * lambdaFactor;
        const newSigma = sigmaHat * sigmaFactor;
        
        // Calculate discrete-time alpha with adjusted lambda
        const alpha = Math.exp(-newLambda * deltaDays);

        // Generate forecast points based on OU process
        // For OU process, E[X_t | X_0 = x_0] = μ + (x_0 - μ)e^(-λt)
        const lastDiff = diffValues[diffValues.length - 1];
        const lastTime = dates[dates.length - 1].getTime();
        
        const forecastPoints: DiffPoint[] = [];
        const upperBoundPoints: DiffPoint[] = [];
        const lowerBoundPoints: DiffPoint[] = [];

        // Create forecast points in a single loop
        for (let i = 0; i <= FORECAST_STEPS; i++) {
            const nextDate = new Date(lastTime + i * delta);
            const alphaPow = Math.pow(alpha, i);
            
            // Mean forecast: E[X_t | X_0] = μ + (X_0 - μ)e^(-λt)
            const meanForecast = muHat + (lastDiff - muHat) * alphaPow;
            
            // Variance forecast: Var[X_t | X_0] = (σ²/2λ)(1 - e^(-2λt))
            const varForecast = (newSigma * newSigma) / (2 * newLambda) * (1 - Math.pow(alpha, 2 * i));
            const stdDev = Math.sqrt(varForecast);
            
            // Create forecast points (main, upper 95% CI, lower 95% CI)
            forecastPoints.push({ 
                inputdate: nextDate, 
                diff: meanForecast, 
                errorChange: 0,
                zspreadRaw1: 0,
                zspreadRaw2: 0,
                zspreadDiff: 0,
                zspreadChange: 0
            });
            
            // Upper bound: mean + 1.96*std (95% confidence interval)
            upperBoundPoints.push({ 
                inputdate: nextDate, 
                diff: meanForecast + 1.96 * stdDev, 
                errorChange: 0,
                zspreadRaw1: 0,
                zspreadRaw2: 0,
                zspreadDiff: 0,
                zspreadChange: 0
            });
            
            // Lower bound: mean - 1.96*std (95% confidence interval)
            lowerBoundPoints.push({ 
                inputdate: nextDate, 
                diff: meanForecast - 1.96 * stdDev, 
                errorChange: 0,
                zspreadRaw1: 0,
                zspreadRaw2: 0,
                zspreadDiff: 0,
                zspreadChange: 0
            });
        }

        return {
            lambda: newLambda,
            mu: muHat,
            sigma: newSigma,
            forecastPoints,
            upperBoundPoints,
            lowerBoundPoints
        };
    }

    // Add utility methods for common chart operations
    private createChartElements(width: number, height: number, chartWidth: number, innerHeight: number) {
        // Clear previous chart
        this.svg.selectAll("*").remove();
        this.svg.attr("width", width).attr("height", height);

        // Create main chart group for error chart
        const errorChart = this.svg.append("g")
            .attr("transform", `translate(${CHART_MARGINS.left}, ${CHART_MARGINS.top})`);

        // Create second chart group for zspread chart
        const zspreadChart = this.svg.append("g")
            .attr("transform", `translate(${CHART_MARGINS.left + chartWidth + CHART_SPACING}, ${CHART_MARGINS.top})`);

        return { errorChart, zspreadChart };
    }

    private createAxis(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        innerWidth: number,
        innerHeight: number
    ) {
        // Create x-axis with adaptive tick count based on available width
        const tickCount = Math.max(2, Math.floor(innerWidth / 100));
        const xAxis = d3.axisBottom(xScale)
            .ticks(tickCount)
            .tickFormat(d3.timeFormat("%b %d, %Y"));
            
        const xAxisGroup = g.append("g")
            .attr("transform", `translate(0, ${innerHeight})`)
            .call(xAxis);

        // Style x-axis text labels
        xAxisGroup.selectAll("text")
            .attr("transform", "rotate(-20)")
            .style("text-anchor", "end")
            .style("font-size", "10px")
            .style("fill", "#666")
            .attr("dy", "1em")
            .attr("dx", "-0.5em");

        // Style x-axis lines and path
        xAxisGroup.selectAll("line, path")
            .style("stroke", "#ddd")
            .style("stroke-width", "1px");

        // Create and style y-axis with 5 ticks
        const yAxis = d3.axisLeft(yScale).ticks(5);
        const yAxisGroup = g.append("g").call(yAxis);

        // Style y-axis text labels
        yAxisGroup.selectAll("text")
            .style("font-size", "10px")
            .style("fill", "#666");

        // Style y-axis lines and path
        yAxisGroup.selectAll("line, path")
            .style("stroke", "#ddd")
            .style("stroke-width", "1px");
    }

    /**
     * Main chart rendering method
     * 
     * Orchestrates the rendering of both charts:
     * 1. Error difference chart with OU process forecasts
     * 2. Z-spread error difference chart with beta-based forecasts
     * 
     * The rendering approach depends on whether the series is stationary,
     * which determines if forecasting can be applied.
     */
    private renderChart(isStationary: boolean) {
        // Set up dimensions for two charts side by side
        const width = this.currentViewport.width;
        const height = this.currentViewport.height;
        const totalWidth = width - CHART_MARGINS.left - CHART_MARGINS.right;
        const chartWidth = (totalWidth - CHART_SPACING) / 2;
        const innerHeight = height - CHART_MARGINS.top - CHART_MARGINS.bottom;

        // Create chart elements
        const { errorChart, zspreadChart } = this.createChartElements(width, height, chartWidth, innerHeight);

        // Add error chart title
        errorChart.append("text")
            .attr("x", 10)
            .attr("y", -35)
            .attr("text-anchor", "start")
            .style("font-size", "14px")
            .style("font-weight", "bold")
            .style("font-family", "Arial, sans-serif")
            .style("fill", "#00818F")
            .text("Error Difference");

        // Check for data
        if (this.diffSeries.length < 1) {
            errorChart.append("text")
                .attr("x", chartWidth / 2)
                .attr("y", innerHeight / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "red")
                .style("font-size", "14px")
                .text("No data to display.");
            return;
        }

        // Create scales and line generator for error chart
        const { xScale, yScale } = this.createScales(isStationary, chartWidth, innerHeight);
        const lineGen = d3.line<DiffPoint>()
            .x(d => xScale(d.inputdate))
            .y(d => yScale(d.diff))
            .curve(d3.curveMonotoneX);

        // Create tooltip behavior
        const tooltip = d3.select("#tooltip");
        const bisectDate = d3.bisector<DiffPoint, Date>(d => d.inputdate).left;

        const showTooltip = (event: MouseEvent, d: DiffPoint) => {
            tooltip
                .style("opacity", 1)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px")
                .html(`Date: ${d.inputdate.toLocaleDateString()}<br/>Value: ${d.diff.toFixed(4)}`);
        };

        const hideTooltip = () => {
            tooltip.style("opacity", 0);
        };

        // Render appropriate chart based on stationarity
        if (isStationary) {
            this.renderStationaryChart(errorChart, xScale, yScale, lineGen, showTooltip, hideTooltip, bisectDate, chartWidth, innerHeight);
        } else {
            this.renderNonStationaryChart(errorChart, xScale, yScale, lineGen, showTooltip, hideTooltip, bisectDate, chartWidth, innerHeight);
        }

        // Render Z-spread chart - pass the same xScale but create a separate yScale for z-spread data
        this.renderZspreadChart(zspreadChart, xScale, chartWidth, innerHeight);

        // Add axes to both charts
        this.createAxis(errorChart, xScale, yScale, chartWidth, innerHeight);
    }

    /**
     * Creates scales for the charts based on data and stationarity
     * 
     * For stationary series, the scales include both historical and forecast data.
     * For non-stationary series, only historical data is used.
     */
    private createScales(isStationary: boolean, innerWidth: number, innerHeight: number) {
        let xScale: d3.ScaleTime<number, number>;
        let yScale: d3.ScaleLinear<number, number>;

        if (isStationary) {
            // For stationary series, calculate OU parameters and include forecast range
            const ouResults = this.calculateOUParameters(
                this.diffSeries.map(d => d.diff),
                this.diffSeries.map(d => d.inputdate)
            );

            // Combine historical and forecast data points for domain calculation
            const allX = this.diffSeries.map(d => d.inputdate)
                .concat(ouResults.forecastPoints.map(d => d.inputdate));
            
            // Include confidence bounds in y-domain calculation
            const allY = this.diffSeries.map(d => d.diff)
                .concat(ouResults.forecastPoints.map(d => d.diff))
                .concat(ouResults.upperBoundPoints.map(d => d.diff))
                .concat(ouResults.lowerBoundPoints.map(d => d.diff));

            // Create time scale for x-axis
            xScale = d3.scaleTime()
                .domain([d3.min(allX) as Date, d3.max(allX) as Date])
                .range([0, innerWidth]);

            // Create linear scale for y-axis with nice rounding
            yScale = d3.scaleLinear()
                .domain([d3.min(allY) as number, d3.max(allY) as number])
                .range([innerHeight, 0])
                .nice();
        } else {
            // For non-stationary series, use only historical data
            xScale = d3.scaleTime()
                .domain([
                    d3.min(this.diffSeries, d => d.inputdate)!,
                    d3.max(this.diffSeries, d => d.inputdate)!
                ])
                .range([0, innerWidth]);

            yScale = d3.scaleLinear()
                .domain([
                    d3.min(this.diffSeries, d => d.diff) as number,
                    d3.max(this.diffSeries, d => d.diff) as number
                ])
                .range([innerHeight, 0])
                .nice();
        }

        return { xScale, yScale };
    }

    /**
     * Renders the zspread chart showing historical zspread differences
     * and forecasted values based on the β coefficient applied to error changes
     */
    private renderZspreadChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        innerWidth: number,
        innerHeight: number
    ) {
        // Clear any existing content
        g.selectAll("*").remove();

        // Add Z-Spread chart title
        g.append("text")
            .attr("x", 10)
            .attr("y", -35)
            .attr("text-anchor", "start")
            .style("font-size", "14px")
            .style("font-weight", "bold")
            .style("font-family", "Arial, sans-serif")
            .style("fill", "#00818F")
            .text("Z-Spread Difference (Forecast via OU Error Changes)");

        // Extract data for plotting
        const zspreadDiffData = this.diffSeries.map(d => ({
            inputdate: d.inputdate,
            value: d.zspreadDiff      // Historical zspread differences
        }));

        if (zspreadDiffData.length === 0) {
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#666")
                .text("No zspread data available");
            return;
        }

        // Get beta coefficient for the relationship between changes
        const { beta } = this.calculateBeta();
        this.beta = beta; // Store beta for display
        
        console.log('Using beta for forecasting:', beta);

        // Prepare arrays for forecast data points
        let forecastZspreadDiffData: {inputdate: Date, value: number}[] = [];
        
        if (this.diffSeriesStationary) {
            // Get OU parameters and forecasts for the error series
            const ouResults = this.calculateOUParameters(
                this.diffSeries.map(d => d.diff),
                this.diffSeries.map(d => d.inputdate)
            );
            
            console.log('OU results:', {
                lambda: ouResults.lambda,
                mu: ouResults.mu,
                sigma: ouResults.sigma,
                forecastFirstPoint: ouResults.forecastPoints[0]
            });
            
            // Extract the last historical error difference value
            const lastErrorDiff = this.diffSeries[this.diffSeries.length - 1].diff;
            // Extract the last historical z-spread difference value
            const lastZspreadDiff = this.diffSeries[this.diffSeries.length - 1].zspreadDiff;
            
            console.log('Last historical values:', { lastErrorDiff, lastZspreadDiff });
            
            // Get the OU process parameters from the left chart
            const mu = ouResults.mu;          // Long-term mean for error_diff
            const lambda = ouResults.lambda;  // Mean-reversion rate
            
            // Calculate time step in days
            const lastTime = this.diffSeries[this.diffSeries.length - 1].inputdate.getTime();
            const delta = ouResults.forecastPoints.length > 1 
                ? (ouResults.forecastPoints[1].inputdate.getTime() - ouResults.forecastPoints[0].inputdate.getTime()) / (1000 * 60 * 60 * 24)
                : 1; // default to 1 day if we can't calculate
            
            console.log('Time delta (days):', delta);
            
            // Start with the last historical zspread_diff value
            let currentZspreadDiff = lastZspreadDiff;
            let currentErrorDiff = lastErrorDiff;
            
            // Generate zspread_diff forecasts using the OU error change model
            // First point is special - we need to connect from the last historical point
            if (ouResults.forecastPoints.length > 0) {
                const firstForecastPoint = ouResults.forecastPoints[0];
                
                // Expected change from OU process
                const expectedErrorChange = lambda * (mu - lastErrorDiff) * delta;
                
                // Apply beta to translate error change to zspread change
                const zspreadChange = beta * expectedErrorChange;
                currentZspreadDiff += zspreadChange;
                currentErrorDiff = firstForecastPoint.diff;
                
                console.log('First forecast point:', {
                    expectedErrorChange,
                    beta,
                    zspreadChange,
                    newZspreadDiff: currentZspreadDiff
                });
                
                forecastZspreadDiffData.push({
                    inputdate: firstForecastPoint.inputdate,
                    value: currentZspreadDiff
                });
                
                // Now process the rest of the forecast points
                for (let i = 1; i < ouResults.forecastPoints.length; i++) {
                    const forecastPoint = ouResults.forecastPoints[i];
                    const prevErrorDiff = currentErrorDiff;
                    currentErrorDiff = forecastPoint.diff;
                    
                    // Expected change from OU process at this step
                    const expectedErrorChange = lambda * (mu - prevErrorDiff) * delta;
                    
                    // Apply beta to translate error change to zspread change
                    const zspreadChange = beta * expectedErrorChange;
                    currentZspreadDiff += zspreadChange;
                    
                    console.log(`Forecast point ${i}:`, {
                        prevErrorDiff,
                        currentErrorDiff: forecastPoint.diff,
                        expectedErrorChange,
                        zspreadChange,
                        newZspreadDiff: currentZspreadDiff
                    });
                    
                    forecastZspreadDiffData.push({
                        inputdate: forecastPoint.inputdate,
                        value: currentZspreadDiff
                    });
                }
            }
        }

        // Display the beta coefficient and explain the relationship
        g.append("text")
            .attr("x", 10)
            .attr("y", -10)
            .attr("fill", "#333")
            .style("font-size", "12px")
            .text(`β = ${beta.toFixed(4)} (Δzspread_diff = β × OU(Δerror_diff))`);

        // Create scales for the chart
        const dataForScales = this.diffSeriesStationary ? 
            [...zspreadDiffData, ...forecastZspreadDiffData] : zspreadDiffData;

        console.log('Data for scales - count:', dataForScales.length);
        if (dataForScales.length > 0) {
            console.log('Data range:', {
                min: d3.min(dataForScales, d => d.value),
                max: d3.max(dataForScales, d => d.value)
            });
        }
        
        // Create a proper y-scale with appropriate padding
        const values = dataForScales.map(d => d.value);
        const yMin = d3.min(values) || 0;
        const yMax = d3.max(values) || 1;
        
        // Ensure the domain has some span (at least 10% of the data range or 0.1, whichever is larger)
        const range = Math.max(0.1, Math.abs(yMax - yMin));
        const padding = range * 0.1; // 10% padding
        
        const zspreadYScale = d3.scaleLinear()
            .domain([yMin - padding, yMax + padding])
            .range([innerHeight, 0])
            .nice();
        
        console.log('Y-scale domain:', zspreadYScale.domain());

        // Create line generator with the right scales
        const zspreadLineGen = d3.line<{inputdate: Date, value: number}>()
            .x(d => xScale(d.inputdate))
            .y(d => zspreadYScale(d.value))
            .curve(d3.curveMonotoneX);

        // Draw historical zspread line
        g.append("path")
            .datum(zspreadDiffData)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .style("stroke-dasharray", "0")
            .attr("d", zspreadLineGen);

        // Draw forecast line if we have stationary data and forecast points
        if (this.diffSeriesStationary && forecastZspreadDiffData.length > 0) {
            const lastHistoricalPoint = zspreadDiffData[zspreadDiffData.length - 1];
            const combinedData = [lastHistoricalPoint, ...forecastZspreadDiffData];
            
            console.log('Combined forecast data - count:', combinedData.length);
            
            g.append("path")
                .datum(combinedData)
                .attr("fill", "none")
                .attr("stroke", "orange")
                .attr("stroke-width", 2)
                .style("stroke-dasharray", "0")
                .attr("d", zspreadLineGen);
        }

        // Add status text
        g.append("text")
            .attr("x", innerWidth - 10)
            .attr("y", -10)
            .attr("text-anchor", "end")
            .attr("fill", this.diffSeriesStationary ? "green" : "red")
            .style("font-size", "12px")
            .text(this.diffSeriesStationary ? 
                "OU Error changes → Z-Spread forecast" : 
                "Series non-stationary. No forecast.");

        // Add tooltip interaction with improved accuracy
        const tooltip = d3.select("#tooltip");
        
        g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mousemove", (event) => {
                const mouseX = xScale.invert(d3.pointer(event)[0]);
                const bisect = d3.bisector<{inputdate: Date, value: number}, Date>(d => d.inputdate).left;
                
                // Find the index of the closest point BEFORE the mouse position
                const index = bisect(zspreadDiffData, mouseX) - 1;
                
                // Make sure the index is valid
                if (index >= 0 && index < zspreadDiffData.length) {
                    const histPoint = zspreadDiffData[index];
                    
                    // Check if we're in the forecast region
                    const lastHistDate = zspreadDiffData[zspreadDiffData.length - 1].inputdate;
                    
                    if (mouseX > lastHistDate && this.diffSeriesStationary && forecastZspreadDiffData.length > 0) {
                        // We're in the forecast region - find the closest forecast point
                        const forecastIndex = bisect(forecastZspreadDiffData, mouseX) - 1;
                        if (forecastIndex >= 0 && forecastIndex < forecastZspreadDiffData.length) {
                            const forecastPoint = forecastZspreadDiffData[forecastIndex];
                            tooltip
                                .style("opacity", 1)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 10) + "px")
                                .html(`Forecast Z-Spread Difference:<br/>
                                    Date: ${forecastPoint.inputdate.toLocaleDateString()}<br/>
                                    Value: ${forecastPoint.value.toFixed(4)}`);
                        }
                    } else {
                        // We're in the historical region
                        tooltip
                            .style("opacity", 1)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px")
                            .html(`Historical Z-Spread Difference:<br/>
                                Date: ${histPoint.inputdate.toLocaleDateString()}<br/>
                                Value: ${histPoint.value.toFixed(4)}`);
                    }
                }
            })
            .on("mouseout", () => tooltip.style("opacity", 0));
        
        // Add y-axis for zspread chart
        this.createAxis(g, xScale, zspreadYScale, innerWidth, innerHeight);
    }

    private renderStationaryChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        lineGen: d3.Line<DiffPoint>,
        showTooltip: (event: MouseEvent, d: DiffPoint) => void,
        hideTooltip: () => void,
        bisectDate: (arr: DiffPoint[], x: Date) => number,
        innerWidth: number,
        innerHeight: number
    ) {
        const ouResults = this.calculateOUParameters(
            this.diffSeries.map(d => d.diff),
            this.diffSeries.map(d => d.inputdate)
        );

        // Store parameters
        this.lambdaHat = ouResults.lambda;
        this.muHat = ouResults.mu;
        this.sigmaHat = ouResults.sigma;

        // Display parameter estimates
        g.append("text")
            .attr("x", 10)
            .attr("y", -10)
            .attr("fill", "#333")
            .style("font-size", "12px")
            .text(`μ = ${this.muHat.toFixed(2)}, λ = ${this.lambdaHat.toFixed(2)} (×${this.lambdaSlider.value}), σ = ${this.sigmaHat.toFixed(2)} (×${this.sigmaSlider.value})`);

        // Add status text
        g.append("text")
            .attr("x", innerWidth - 10)
            .attr("y", -10)
            .attr("text-anchor", "end")
            .style("fill", "green")
            .style("font-size", "12px")
            .text("ADF passed: Series stationary. OU applied.");

        // Draw forecast confidence bands
        g.append("path")
            .datum(ouResults.lowerBoundPoints)
            .attr("fill", "none")
            .attr("stroke", "grey")
            .attr("stroke-width", 1)
            .style("stroke-dasharray", "3,3")
            .attr("d", lineGen);

        g.append("path")
            .datum(ouResults.upperBoundPoints)
            .attr("fill", "none")
            .attr("stroke", "grey")
            .attr("stroke-width", 1)
            .style("stroke-dasharray", "3,3")
            .attr("d", lineGen);

        // Draw forecast mean line
        g.append("path")
            .datum(ouResults.forecastPoints)
            .attr("fill", "none")
            .attr("stroke", "orange")
            .attr("stroke-width", 2)
            .style("stroke-dasharray", "0")
            .attr("d", lineGen);

        // Draw historical data line
        g.append("path")
            .datum(this.diffSeries)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .style("stroke-dasharray", "0")
            .attr("d", lineGen);

        // Add tooltip interaction overlay for the entire chart area
        const overlay = g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mousemove", (event) => {
                const mouseX = xScale.invert(d3.pointer(event)[0]);
                
                // Find the closest point in historical data
                const histIndex = bisectDate(this.diffSeries, mouseX);
                const histPoint = this.diffSeries[histIndex];
                
                // Find the closest point in forecast data
                const forecastIndex = bisectDate(ouResults.forecastPoints, mouseX);
                const forecastPoint = ouResults.forecastPoints[forecastIndex];
                
                // Find the closest points in upper and lower bounds
                const upperPoint = ouResults.upperBoundPoints[forecastIndex];
                const lowerPoint = ouResults.lowerBoundPoints[forecastIndex];

                // Determine which point to show based on which is closer to the mouse
                let tooltipContent = "";
                
                if (histPoint && forecastPoint) {
                    const histDist = Math.abs(histPoint.inputdate.getTime() - mouseX.getTime());
                    const forecastDist = Math.abs(forecastPoint.inputdate.getTime() - mouseX.getTime());
                    
                    if (histDist < forecastDist) {
                        tooltipContent = `Historical Data:<br/>
                            Date: ${histPoint.inputdate.toLocaleDateString()}<br/>
                            Value: ${histPoint.diff.toFixed(4)}`;
                    } else {
                        tooltipContent = `Forecast:<br/>
                            Date: ${forecastPoint.inputdate.toLocaleDateString()}<br/>
                            Value: ${forecastPoint.diff.toFixed(4)}<br/>
                            Upper Bound: ${upperPoint.diff.toFixed(4)}<br/>
                            Lower Bound: ${lowerPoint.diff.toFixed(4)}`;
                    }
                } else if (histPoint) {
                    tooltipContent = `Historical Data:<br/>
                        Date: ${histPoint.inputdate.toLocaleDateString()}<br/>
                        Value: ${histPoint.diff.toFixed(4)}`;
                } else if (forecastPoint) {
                    tooltipContent = `Forecast:<br/>
                        Date: ${forecastPoint.inputdate.toLocaleDateString()}<br/>
                        Value: ${forecastPoint.diff.toFixed(4)}<br/>
                        Upper Bound: ${upperPoint.diff.toFixed(4)}<br/>
                        Lower Bound: ${lowerPoint.diff.toFixed(4)}`;
                }

                if (tooltipContent) {
                    const tooltip = d3.select("#tooltip");
                    tooltip
                        .style("opacity", 1)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px")
                        .html(tooltipContent);
                }
            })
            .on("mouseout", hideTooltip);
    }

    private renderNonStationaryChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        lineGen: d3.Line<DiffPoint>,
        showTooltip: (event: MouseEvent, d: DiffPoint) => void,
        hideTooltip: () => void,
        bisectDate: (arr: DiffPoint[], x: Date) => number,
        innerWidth: number,
        innerHeight: number
    ) {
        // Draw historical data line
        g.append("path")
            .datum(this.diffSeries)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .style("stroke-dasharray", "0")
            .attr("d", lineGen);

        // Add status text
        g.append("text")
            .attr("x", innerWidth - 10)
            .attr("y", -10)
            .attr("text-anchor", "end")
            .style("fill", "red")
            .style("font-size", "12px")
            .text("ADF failed: Series non-stationary. OU not applied.");

        // Add tooltip interaction overlay
        g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mousemove", (event) => {
                const mouseX = xScale.invert(d3.pointer(event)[0]);
                const index = bisectDate(this.diffSeries, mouseX);
                const d = this.diffSeries[index];
                if (d) showTooltip(event, d);
            })
            .on("mouseout", hideTooltip);
    }
}
