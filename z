/**
 * Ornstein-Uhlenbeck Process Forecasting for Bond Error and Z-Spread Differences
 * 
 * See README.md for detailed documentation and usage instructions.
 */

"use strict";
import "./../style/visual.less";
import * as d3 from "d3";
import powerbiVisualsApi from "powerbi-visuals-api";
import IVisual = powerbiVisualsApi.extensibility.visual.IVisual;
import VisualConstructorOptions = powerbiVisualsApi.extensibility.visual.VisualConstructorOptions;
import VisualUpdateOptions = powerbiVisualsApi.extensibility.visual.VisualUpdateOptions;
import DataView = powerbiVisualsApi.DataView;

// Constants
const CHART_MARGINS = { top: 50, right: 40, bottom: 120, left: 70 };
const CHART_SPACING = 50; // Increased spacing between charts
const FORECAST_STEPS = 30;
const ADF_THRESHOLD = -3;
const DEFAULT_LAMBDA = 1.0;
const DEFAULT_SIGMA = 1.0;

/**
 * Interface representing a single row of input data
 */
interface DataRow {
    inputdate: Date;
    context1: string;
    isin1: string;
    isin2: string;
    bond1: string;
    bond2: string;
    error: number;
    zspread: number;
}

/**
 * Interface for the difference series points
 */
interface DiffPoint {
    inputdate: Date;
    diff: number;                // error difference
    errorChange: number;         // daily change in error difference
    zspreadRaw1: number;         // raw zspread for bond1
    zspreadRaw2: number;         // raw zspread for bond2
    zspreadDiff: number;         // raw zspread difference
    zspreadChange: number;       // daily change in zspread difference
}

/**
 * Interface for OU process parameters and forecasts
 */
interface OUResults {
    lambda: number;
    mu: number;
    sigma: number;
    forecastPoints: DiffPoint[];
    upperBoundPoints: DiffPoint[];
    lowerBoundPoints: DiffPoint[];
}

/**
 * Memoization utility for expensive calculations
 * Stores previously computed results to avoid redundant calculations
 * by caching results based on input arguments
 */
function memoize<T, R>(fn: (arg: T) => R): (arg: T) => R {
    const cache = new Map<string, R>();
    return (arg: T) => {
        const key = JSON.stringify(arg);
        if (cache.has(key)) {
            return cache.get(key)!;
        }
        const result = fn(arg);
        cache.set(key, result);
        return result;
    };
}

export class Visual implements IVisual {
    // DOM Elements
    private target: HTMLElement;
    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;
    private dropdownPairs: HTMLSelectElement;
    private lambdaSlider: HTMLInputElement;
    private sigmaSlider: HTMLInputElement;

    // Data Storage
    private allData: DataRow[] = [];
    private diffSeries: DiffPoint[] = [];

    // Ornstein-Uhlenbeck Parameters
    private lambdaHat: number = 0;
    private muHat: number = 0;
    private sigmaHat: number = 0;
    private delta: number = 1;

    // Viewport Configuration
    private currentViewport: { width: number; height: number } = { width: 600, height: 300 };
    private diffSeriesStationary: boolean = false;
    private beta: number = 0;

    // Add cache for processed data
    private processedData: Map<string, DiffPoint[]> = new Map();

    constructor(options: VisualConstructorOptions) {
        this.initializeVisual(options);
    }

    /**
     * Initializes the visual with controls and event listeners
     */
    private initializeVisual(options: VisualConstructorOptions): void {
        this.target = options.element;
        
        // Clear completely before initializing
        this.target.innerHTML = "";

        // Build DOM in a more efficient order
        this.createControlContainer();
        this.createTooltip();
        this.createSVGContainer();
        this.initializeControls();
    }

    /**
     * Creates the control container with dropdown and sliders
     */
    private createControlContainer(): void {
        // Use document fragment for better performance
        const fragment = document.createDocumentFragment();
        const controlContainer = document.createElement("div");
        controlContainer.id = "control-container";
        
        // Create dropdown container
        const dropdownContainer = document.createElement("div");
        dropdownContainer.id = "dropdown-container";
        
        const dropdownLabel = document.createElement("label");
        dropdownLabel.setAttribute("for", "pairDropdown");
        dropdownLabel.textContent = "Select Pair (Bond1 vs Bond2):";
        
        this.dropdownPairs = document.createElement("select");
        this.dropdownPairs.id = "pairDropdown";
        this.dropdownPairs.style.fontSize = "10px";
        
        dropdownContainer.appendChild(dropdownLabel);
        dropdownContainer.appendChild(this.dropdownPairs);
        
        // Create slider container
        const sliderContainer = document.createElement("div");
        sliderContainer.id = "slider-container";
        
        // Lambda slider
        const lambdaContainer = document.createElement("div");
        const lambdaLabel = document.createElement("label");
        lambdaLabel.setAttribute("for", "lambdaSlider");
        lambdaLabel.textContent = "Lambda Factor:";
        
        this.lambdaSlider = document.createElement("input");
        this.lambdaSlider.id = "lambdaSlider";
        this.lambdaSlider.type = "range";
        this.lambdaSlider.min = "0.1";
        this.lambdaSlider.max = "2.0";
        this.lambdaSlider.step = "0.01";
        this.lambdaSlider.value = DEFAULT_LAMBDA.toString();
        
        const lambdaValue = document.createElement("span");
        lambdaValue.id = "lambdaValue";
        lambdaValue.textContent = DEFAULT_LAMBDA.toString();
        
        lambdaContainer.appendChild(lambdaLabel);
        lambdaContainer.appendChild(this.lambdaSlider);
        lambdaContainer.appendChild(lambdaValue);
        
        // Sigma slider
        const sigmaContainer = document.createElement("div");
        const sigmaLabel = document.createElement("label");
        sigmaLabel.setAttribute("for", "sigmaSlider");
        sigmaLabel.textContent = "Sigma Factor:";
        
        this.sigmaSlider = document.createElement("input");
        this.sigmaSlider.id = "sigmaSlider";
        this.sigmaSlider.type = "range";
        this.sigmaSlider.min = "0.1";
        this.sigmaSlider.max = "1.5";
        this.sigmaSlider.step = "0.01";
        this.sigmaSlider.value = DEFAULT_SIGMA.toString();
        
        const sigmaValue = document.createElement("span");
        sigmaValue.id = "sigmaValue";
        sigmaValue.textContent = DEFAULT_SIGMA.toString();
        
        sigmaContainer.appendChild(sigmaLabel);
        sigmaContainer.appendChild(this.sigmaSlider);
        sigmaContainer.appendChild(sigmaValue);
        
        // Assemble slider container
        sliderContainer.appendChild(lambdaContainer);
        sliderContainer.appendChild(sigmaContainer);
        
        // Assemble final control container
        controlContainer.appendChild(dropdownContainer);
        controlContainer.appendChild(sliderContainer);
        fragment.appendChild(controlContainer);
        
        // Single DOM manipulation for better performance
        this.target.appendChild(fragment);
    }

    /**
     * Creates the tooltip element
     */
    private createTooltip(): void {
        const tooltip = document.createElement("div");
        tooltip.id = "tooltip";
        Object.assign(tooltip.style, {
            position: "absolute",
            padding: "8px",
            background: "rgba(255, 255, 255, 0.9)",
            border: "1px solid #ddd",
            borderRadius: "4px",
            pointerEvents: "none",
            fontSize: "12px",
            zIndex: "1000",
            opacity: "0"
        });
        this.target.appendChild(tooltip);
    }

    /**
     * Initializes control elements and event listeners with performance optimizations
     */
    private initializeControls(): void {
        // Use debounced event handlers to prevent excessive rendering
        const debounce = (fn: Function, delay: number) => {
            let timer: number | null = null;
            return (...args: any[]) => {
                if (timer) window.clearTimeout(timer);
                timer = window.setTimeout(() => fn(...args), delay);
            };
        };
        
        // Add event listeners with performance optimizations
        this.dropdownPairs.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
        
        // Use input event for real-time updates on sliders
        this.lambdaSlider.addEventListener("input", () => {
            (document.getElementById("lambdaValue") as HTMLElement).innerText = this.lambdaSlider.value;
        });
        
        // Use change event for rendering only when slider stops (better performance)
        this.lambdaSlider.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
        
        this.sigmaSlider.addEventListener("input", () => {
            (document.getElementById("sigmaValue") as HTMLElement).innerText = this.sigmaSlider.value;
        });
        
        this.sigmaSlider.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
    }

    /**
     * Creates the SVG container for the chart
     */
    private createSVGContainer(): void {
        this.svg = d3.select(this.target)
            .append("svg")
            .classed("ou-estimation-visual", true);
    }

    /**
     * Parses a single row of data with validation
     */
    private parseDataRow(row: any[]): DataRow | null {
        let dateVal: Date;
        if (row[0] instanceof Date) {
            dateVal = row[0];
        } else if (typeof row[0] === 'string') {
            dateVal = new Date(row[0]);
            if (isNaN(dateVal.getTime())) return null;
        } else if (typeof row[0] === 'number') {
            dateVal = new Date(row[0]);
        } else {
            return null;
        }

        return {
            inputdate: dateVal,
            context1: row[1]?.toString() || "",
            isin1: row[2]?.toString() || "",
            isin2: row[3]?.toString() || "",
            bond1: row[4]?.toString() || "",
            bond2: row[5]?.toString() || "",
            error: +row[6],
            zspread: +row[7]
        };
    }

    /**
     * Resets sliders to default values
     */
    private resetSliders(): void {
        this.lambdaSlider.value = DEFAULT_LAMBDA.toString();
        this.sigmaSlider.value = DEFAULT_SIGMA.toString();
        (document.getElementById("lambdaValue") as HTMLElement).innerText = DEFAULT_LAMBDA.toString();
        (document.getElementById("sigmaValue") as HTMLElement).innerText = DEFAULT_SIGMA.toString();
    }

    public update(options: VisualUpdateOptions) {
        const dataView: DataView = options.dataViews?.[0];
        if (!dataView?.table) return;
        
        this.currentViewport = options.viewport || { width: 600, height: 300 };
        this.resetSliders();

        const rows = dataView.table.rows;
        if (!rows?.length) return;

        // Parse and sort data
        this.allData = rows
            .map(row => this.parseDataRow(row))
            .filter((row): row is DataRow => row !== null)
            .sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());

        // Update dropdown with latest P_VALUE rows
        this.updateDropdown();
        
        // Update chart if data is available
        if (this.allData.length > 0) {
            this.updateChartsInner();
        }
    }

    /**
     * Updates the dropdown with the latest P_VALUE rows
     * 
     * This method filters the most recent P_VALUE entries and populates
     * the dropdown with unique bond pairs for selection
     */
    private updateDropdown(): void {
        // Filter rows with context1 = "P_VALUE"
        const pValueRows = this.allData.filter(d => 
            d.context1.trim().toUpperCase() === "P_VALUE"
        );

        if (pValueRows.length === 0) {
            this.dropdownPairs.options.length = 0;
            this.svg.selectAll("*").remove();
            return;
        }

        // Find the most recent date in the P_VALUE rows
        const maxDate = d3.max(pValueRows, d => d.inputdate.getTime())!;
        const latestRows = pValueRows.filter(d => 
            d.inputdate.toDateString() === new Date(maxDate).toDateString()
        );

        const uniquePairs = Array.from(new Set(
            latestRows.map(row => `${row.bond1} vs ${row.bond2}`)
        ));

        this.dropdownPairs.options.length = 0;
        uniquePairs.forEach(pair => {
            const opt = document.createElement("option");
            opt.value = pair;
            opt.text = pair;
            opt.style.fontSize = "10px";
            this.dropdownPairs.appendChild(opt);
        });

        if (uniquePairs.length > 0) {
            this.dropdownPairs.value = uniquePairs[0];
        }
    }

    /**
     * Core method to update charts based on the selected bond pair
     */
    private updateChartsInner() {
        if (this.dropdownPairs.options.length === 0) return;
        
        const selectedPair = this.dropdownPairs.value;
        if (!selectedPair) return;
        
        const [selectedBond1, selectedBond2] = selectedPair.split(" vs ");

        // Clear previous data
        this.diffSeries = [];

        // Filter and compute difference series for both error and zspread
        const errorRows = this.allData.filter(d => 
            d.context1.trim().toUpperCase() === "ERROR" &&
            (d.bond1.trim() === selectedBond1.trim() || d.bond1.trim() === selectedBond2.trim())
        );

        const mapBond1 = new Map<string, {error: number, zspread: number}>();
        const mapBond2 = new Map<string, {error: number, zspread: number}>();
        
        errorRows.forEach(d => {
            const key = d.inputdate.toDateString();
            const value = { 
                error: d.error, 
                zspread: d.zspread
            };
            
            if (d.bond1.trim() === selectedBond1.trim()) {
                mapBond1.set(key, value);
            } else if (d.bond1.trim() === selectedBond2.trim()) {
                mapBond2.set(key, value);
            }
        });

        // Collect dates where both bonds have data
        const commonDates: string[] = [];
        mapBond1.forEach((_, key) => {
            if (mapBond2.has(key)) {
                commonDates.push(key);
            }
        });
        
        // Sort dates chronologically
        commonDates.sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
        
        // Create diffSeries with differences and daily changes
        for (let i = 0; i < commonDates.length; i++) {
            const key = commonDates[i];
            const val1 = mapBond1.get(key)!;
                const val2 = mapBond2.get(key)!;
            
            // Calculate differences for current day
            const errorDiff = val2.error - val1.error;
            const zspreadDiff = val2.zspread - val1.zspread;
            
            // Initialize daily changes (will be set in next loop iteration if not the first point)
            let errorChange = 0;
            let zspreadChange = 0;
            
            // For points beyond the first one, calculate daily changes
            if (i > 0) {
                const prevKey = commonDates[i-1];
                const prevVal1 = mapBond1.get(prevKey)!;
                const prevVal2 = mapBond2.get(prevKey)!;
                const prevErrorDiff = prevVal2.error - prevVal1.error;
                const prevZspreadDiff = prevVal2.zspread - prevVal1.zspread;
                
                errorChange = errorDiff - prevErrorDiff;
                zspreadChange = zspreadDiff - prevZspreadDiff;
                
                // Update previous point's change values since we now know them
                if (i === 1) {
                    // For the first point, set changes to 0
                    this.diffSeries[0].errorChange = 0;
                    this.diffSeries[0].zspreadChange = 0;
                }
            }
            
            // Add the current point
            this.diffSeries.push({
                    inputdate: new Date(key),
                diff: errorDiff,
                errorChange: errorChange,
                zspreadRaw1: val1.zspread,
                zspreadRaw2: val2.zspread,
                zspreadDiff: zspreadDiff,
                zspreadChange: zspreadChange
            });
        }

        if (this.diffSeries.length < 2) {
            this.renderChart(false);
            return;
        }

        // Calculate beta coefficient
        const { beta } = this.calculateBeta();
        this.beta = beta;

        // Apply ADF test to check for stationarity of error_diff
        const diffs = this.diffSeries.map(d => d.diff);
        this.diffSeriesStationary = this.performADFTest(diffs);
        
        this.renderChart(this.diffSeriesStationary);
    }

    /**
     * Calculates the beta coefficient using covariance and variance
     */
    private calculateBeta(): { beta: number } {
        // Check if we have enough data points
        if (this.diffSeries.length < 2) {
            return { beta: 0 };
        }
        
        // Skip the first point which doesn't have change values
        const points = this.diffSeries.slice(1);
        
        // Extract the x and y values
        const xValues = points.map(p => p.errorChange);
        const yValues = points.map(p => p.zspreadChange);
        
        // Calculate means using d3
        const xMean = d3.mean(xValues) || 0;
        const yMean = d3.mean(yValues) || 0;
        
        // Calculate covariance
        let covariance = 0;
        for (let i = 0; i < xValues.length; i++) {
            covariance += (xValues[i] - xMean) * (yValues[i] - yMean);
        }
        covariance /= xValues.length;
        
        // Calculate variance using d3
        const variance = d3.variance(xValues) || 0;
        
        // Calculate beta = cov(x,y) / var(x)
        return { beta: Math.abs(variance) > 1e-10 ? covariance / variance : 0 };
    }

    // Update the ADF test implementation with better comments
    private performADFTest = memoize((data: number[]): boolean => {
        if (data.length < 3) return false;
        
        // ADF test equation: Δy_t = α + βy_{t-1} + ε_t
        // where β = ρ - 1 and ρ is the autoregressive coefficient
        
        // Create first difference series (Δy_t)
        const dX = data.slice(1).map((val, i) => val - data[i]);
        // Create lagged series (y_{t-1})
        const lagX = data.slice(0, -1);
        
        // Calculate means for demeaning
        const meanLag = d3.mean(lagX)!;
        const meanDX = d3.mean(dX)!;
        
        // Calculate numerator for the slope coefficient: Σ(y_{t-1} - mean_y)(Δy_t - mean_Δy)
        const num = dX.reduce((sum, val, i) => 
            sum + (lagX[i] - meanLag) * (val - meanDX), 0);
        // Calculate denominator: Σ(y_{t-1} - mean_y)²
        const den = lagX.reduce((sum, val) => 
            sum + Math.pow(val - meanLag, 2), 0);
            
        // Calculate slope coefficient β
        const slope = num / den;
        
        // Calculate sum of squared residuals for standard error
        const ssr = dX.reduce((sum, val, i) => 
            sum + Math.pow(val - slope * lagX[i], 2), 0);
            
        // Calculate variance of residuals
        const s2 = ssr / (dX.length - 2);
        // Calculate standard error of slope coefficient
        const se = Math.sqrt(s2 / den);
        // Calculate t-statistic (Dickey-Fuller test statistic)
        const tStat = slope / se;
        
        // Compare against critical value ADF_THRESHOLD (typically -3)
        // If t-statistic < threshold, reject null hypothesis of unit root (non-stationarity)
        return tStat < ADF_THRESHOLD;
    });

    /**
     * Calculates Ornstein-Uhlenbeck process parameters and forecasts
     */
    private calculateOUParameters(diffValues: number[], dates: Date[]): OUResults {
        // For insufficient data, return defaults
        if (diffValues.length < 2) {
            return {
                lambda: 0, mu: 0, sigma: 0,
                forecastPoints: [], upperBoundPoints: [], lowerBoundPoints: []
            };
        }
        
        const n = diffValues.length - 1;
        const diffMean = d3.mean(diffValues) || 0;
        
        // Calculate time parameters
        const timeSpan = dates[dates.length - 1].getTime() - dates[0].getTime();
        const delta = timeSpan / n;
        const deltaDays = delta / (1000 * 60 * 60 * 24);
        
        // Calculate auto-correlation coefficient
        const deviations = diffValues.map(val => val - diffMean);
        const autoCorr = deviations.slice(1).reduce((sum, val, i) => 
            sum + val * deviations[i], 0) / deviations.slice(0, -1).reduce((sum, val) => 
            sum + val * val, 0);
        
        // Ensure alpha is in valid range
        const alphaHat = Math.max(Math.min(autoCorr, 0.9999999), -0.9999999);
        
        // Calculate lambda, mu, and sigma
        const lambdaHat = -Math.log(alphaHat) / deltaDays;
        
        // Calculate long-term mean from residuals
        const muHat = diffValues.slice(1).reduce((sum, val, i) => 
            sum + (val - alphaHat * diffValues[i]), 0) / (n * (1 - alphaHat));
        
        // Calculate volatility
        const residuals = diffValues.slice(1).map((val, i) => 
            val - alphaHat * diffValues[i] - (1 - alphaHat) * muHat);
        const sumSq = residuals.reduce((sum, r) => sum + r * r, 0);
        const sigmaSqHat = (2 * lambdaHat) / (1 - alphaHat * alphaHat) * (1 / n) * sumSq;
        const sigmaHat = Math.sqrt(Math.max(sigmaSqHat, 0));
        
        // Apply user scaling factors
        const lambdaFactor = parseFloat(this.lambdaSlider.value);
        const sigmaFactor = parseFloat(this.sigmaSlider.value);
        const newLambda = lambdaHat * lambdaFactor;
        const newSigma = sigmaHat * sigmaFactor;
        
        // Calculate discrete-time alpha
        const alpha = Math.exp(-newLambda * deltaDays);
        
        // Generate forecasts
        const lastDiff = diffValues[diffValues.length - 1];
        const lastTime = dates[dates.length - 1].getTime();
        
        const forecastPoints: DiffPoint[] = [];
        const upperBoundPoints: DiffPoint[] = [];
        const lowerBoundPoints: DiffPoint[] = [];
        
        // Generate forecast points in a single loop
        for (let i = 0; i <= FORECAST_STEPS; i++) {
            const nextDate = new Date(lastTime + i * delta);
            const alphaPow = Math.pow(alpha, i);
            
            const meanForecast = muHat + (lastDiff - muHat) * alphaPow;
            const varForecast = (newSigma * newSigma) / (2 * newLambda) * (1 - Math.pow(alpha, 2 * i));
            const stdDev = Math.sqrt(varForecast);
            
            // Create base point with common properties
            const basePoint = {
                inputdate: nextDate,
                errorChange: 0,
                zspreadRaw1: 0,
                zspreadRaw2: 0,
                zspreadDiff: 0,
                zspreadChange: 0
            };
            
            // Add all forecast points
            forecastPoints.push({ ...basePoint, diff: meanForecast });
            upperBoundPoints.push({ ...basePoint, diff: meanForecast + 1.96 * stdDev });
            lowerBoundPoints.push({ ...basePoint, diff: meanForecast - 1.96 * stdDev });
        }
        
        return { lambda: newLambda, mu: muHat, sigma: newSigma, 
                 forecastPoints, upperBoundPoints, lowerBoundPoints };
    }

    // Add utility methods for common chart operations
    private createChartElements(width: number, height: number, chartWidth: number, innerHeight: number) {
        // Clear previous chart
        this.svg.selectAll("*").remove();
        this.svg.attr("width", width).attr("height", height);

        // Create main chart group for error chart
        const errorChart = this.svg.append("g")
            .attr("transform", `translate(${CHART_MARGINS.left}, ${CHART_MARGINS.top})`);

        // Create second chart group for zspread chart
        const zspreadChart = this.svg.append("g")
            .attr("transform", `translate(${CHART_MARGINS.left + chartWidth + CHART_SPACING}, ${CHART_MARGINS.top})`);

        return { errorChart, zspreadChart };
    }

    private createAxis(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        innerWidth: number,
        innerHeight: number
    ) {
        // Create x-axis with adaptive tick count based on available width
        const tickCount = Math.max(2, Math.floor(innerWidth / 100));
        const xAxis = d3.axisBottom(xScale)
            .ticks(tickCount)
            .tickFormat(d3.timeFormat("%b %d, %Y"));
            
        const xAxisGroup = g.append("g")
            .attr("transform", `translate(0, ${innerHeight})`)
            .call(xAxis);

        // Style x-axis text labels
        xAxisGroup.selectAll("text")
            .attr("transform", "rotate(-20)")
            .style("text-anchor", "end")
            .style("font-size", "10px")
            .style("fill", "#666")
            .attr("dy", "1em")
            .attr("dx", "-0.5em");

        // Style x-axis lines and path
        xAxisGroup.selectAll("line, path")
            .style("stroke", "#ddd")
            .style("stroke-width", "1px");

        // Create and style y-axis with 5 ticks
        const yAxis = d3.axisLeft(yScale).ticks(5);
        const yAxisGroup = g.append("g").call(yAxis);

        // Style y-axis text labels
        yAxisGroup.selectAll("text")
            .style("font-size", "10px")
            .style("fill", "#666");

        // Style y-axis lines and path
        yAxisGroup.selectAll("line, path")
            .style("stroke", "#ddd")
            .style("stroke-width", "1px");
    }

    /**
     * Main chart rendering method that orchestrates the rendering of both charts
     */
    private renderChart(isStationary: boolean) {
        // Set up dimensions
        const width = this.currentViewport.width;
        const height = this.currentViewport.height;
        const totalWidth = width - CHART_MARGINS.left - CHART_MARGINS.right;
        const chartWidth = (totalWidth - CHART_SPACING) / 2;
        const innerHeight = height - CHART_MARGINS.top - CHART_MARGINS.bottom;

        // Create chart elements
        const { errorChart, zspreadChart } = this.createChartElements(width, height, chartWidth, innerHeight);

        // Add error chart title
        errorChart.append("text")
            .attr("x", 10)
            .attr("y", -35)
            .attr("text-anchor", "start")
            .style("font-size", "14px")
            .style("font-weight", "bold")
            .style("font-family", "Arial, sans-serif")
            .style("fill", "#00818F")
            .text("Error Difference");

        // Check for data
        if (this.diffSeries.length < 1) {
            errorChart.append("text")
                .attr("x", chartWidth / 2)
                .attr("y", innerHeight / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "red")
                .style("font-size", "14px")
                .text("No data to display.");
            return;
        }

        // Create scales and line generator
        const { xScale, yScale } = this.createScales(isStationary, chartWidth, innerHeight);
        const lineGen = d3.line<DiffPoint>()
            .x(d => xScale(d.inputdate))
            .y(d => yScale(d.diff))
            .curve(d3.curveMonotoneX);

        // Create tooltip behavior
        const tooltip = d3.select("#tooltip");
        const bisectDate = d3.bisector<DiffPoint, Date>(d => d.inputdate).left;

        const showTooltip = (event: MouseEvent, d: DiffPoint) => {
            tooltip
                .style("opacity", 1)
                .style("left", `${event.pageX + 10}px`)
                .style("top", `${event.pageY - 10}px`)
                .html(`Date: ${d.inputdate.toLocaleDateString()}<br/>Value: ${d.diff.toFixed(4)}`);
        };

        const hideTooltip = () => tooltip.style("opacity", 0);

        // Render appropriate chart based on stationarity
        if (isStationary) {
            this.renderStationaryChart(errorChart, xScale, yScale, lineGen, showTooltip, 
                hideTooltip, bisectDate, chartWidth, innerHeight);
        } else {
            this.renderNonStationaryChart(errorChart, xScale, yScale, lineGen, showTooltip, 
                hideTooltip, bisectDate, chartWidth, innerHeight);
        }

        // Render Z-spread chart
        this.renderZspreadChart(zspreadChart, xScale, chartWidth, innerHeight);

        // Add axes to error chart
        this.createAxis(errorChart, xScale, yScale, chartWidth, innerHeight);
    }

    /**
     * Creates scales for the charts based on data and stationarity
     * 
     * For stationary series, the scales include both historical and forecast data.
     * For non-stationary series, only historical data is used.
     */
    private createScales(isStationary: boolean, innerWidth: number, innerHeight: number) {
        let xScale: d3.ScaleTime<number, number>;
        let yScale: d3.ScaleLinear<number, number>;

        if (isStationary) {
            // For stationary series, calculate OU parameters and include forecast range
            const ouResults = this.calculateOUParameters(
                this.diffSeries.map(d => d.diff),
                this.diffSeries.map(d => d.inputdate)
            );

            // Combine historical and forecast data points for domain calculation
            const allX = this.diffSeries.map(d => d.inputdate)
                .concat(ouResults.forecastPoints.map(d => d.inputdate));
            
            // Include confidence bounds in y-domain calculation
            const allY = this.diffSeries.map(d => d.diff)
                .concat(ouResults.forecastPoints.map(d => d.diff))
                .concat(ouResults.upperBoundPoints.map(d => d.diff))
                .concat(ouResults.lowerBoundPoints.map(d => d.diff));

            // Create time scale for x-axis
            xScale = d3.scaleTime()
            .domain([d3.min(allX) as Date, d3.max(allX) as Date])
            .range([0, innerWidth]);

            // Create linear scale for y-axis with nice rounding
            yScale = d3.scaleLinear()
            .domain([d3.min(allY) as number, d3.max(allY) as number])
            .range([innerHeight, 0])
            .nice();
        } else {
            // For non-stationary series, use only historical data
            xScale = d3.scaleTime()
                .domain([
                    d3.min(this.diffSeries, d => d.inputdate)!,
                    d3.max(this.diffSeries, d => d.inputdate)!
                ])
                .range([0, innerWidth]);

            yScale = d3.scaleLinear()
                .domain([
                    d3.min(this.diffSeries, d => d.diff) as number,
                    d3.max(this.diffSeries, d => d.diff) as number
                ])
                .range([innerHeight, 0])
                .nice();
        }

        return { xScale, yScale };
    }

    /**
     * Renders the Z-spread chart with historical data and forecasts
     */
    private renderZspreadChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        innerWidth: number,
        innerHeight: number
    ) {
        g.selectAll("*").remove();

        // Add chart title with more intuitive wording
        g.append("text")
            .attr("x", 10)
            .attr("y", -35)
            .attr("text-anchor", "start")
            .style("font-size", "14px")
            .style("font-weight", "bold")
            .style("font-family", "Arial, sans-serif")
            .style("fill", "#00818F")
            .text("Z-Spread Forecast Based on Error Changes");

        // Extract historical data
        const zspreadDiffData = this.diffSeries.map(d => ({
            inputdate: d.inputdate,
            value: d.zspreadDiff,
            isHistorical: true
        }));

        if (zspreadDiffData.length === 0) {
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#666")
                .text("No zspread data available");
            return;
        }

        // Calculate beta coefficient
        const { beta } = this.calculateBeta();
        this.beta = beta;

        // Generate forecasts if series is stationary
        let allData = [...zspreadDiffData];
        
        if (this.diffSeriesStationary) {
            // Calculate OU parameters
            const ouResults = this.calculateOUParameters(
                this.diffSeries.map(d => d.diff),
                this.diffSeries.map(d => d.inputdate)
            );
            
            // Get parameters for forecast
            const lastErrorDiff = this.diffSeries[this.diffSeries.length - 1].diff;
            const lastZspreadDiff = this.diffSeries[this.diffSeries.length - 1].zspreadDiff;
            const mu = ouResults.mu;
            const lambda = ouResults.lambda;
            
            // Calculate time step
            const lastTime = this.diffSeries[this.diffSeries.length - 1].inputdate.getTime();
            const delta = ouResults.forecastPoints.length > 1 
                ? (ouResults.forecastPoints[1].inputdate.getTime() - ouResults.forecastPoints[0].inputdate.getTime()) / (1000 * 60 * 60 * 24)
                : 1;
            
            // Generate forecasts
            if (ouResults.forecastPoints.length > 0) {
                let currentZspreadDiff = lastZspreadDiff;
                let currentErrorDiff = lastErrorDiff;
                
                // Process all forecast points
                ouResults.forecastPoints.forEach((point, i) => {
                    // For first point, use last historical error diff
                    const prevErrorDiff = i === 0 ? lastErrorDiff : currentErrorDiff;
                    currentErrorDiff = point.diff;
                    
                    // Calculate expected change from OU process
                    const expectedErrorChange = lambda * (mu - prevErrorDiff) * delta;
                    
                    // Apply beta to error change
                    const zspreadChange = beta * expectedErrorChange;
                    currentZspreadDiff += zspreadChange;
                    
                    // Add to forecast data
                    allData.push({
                        inputdate: point.inputdate,
                        value: currentZspreadDiff,
                        isHistorical: false
                    });
                });
            }
        }

        // Display beta coefficient with user-friendly explanation
        g.append("text")
            .attr("x", 10)
            .attr("y", -10)
            .attr("fill", "#333")
            .style("font-size", "12px")
            .text(`Sensitivity: β = ${beta.toFixed(4)} (When Error changes by 1, Z-Spread changes by ${beta.toFixed(4)})`);

        // Calculate scale domain with padding
        const values = allData.map(d => d.value);
        const yMin = d3.min(values) || 0;
        const yMax = d3.max(values) || 1;
        const range = Math.max(0.1, Math.abs(yMax - yMin));
        const padding = range * 0.1;
        
        const zspreadYScale = d3.scaleLinear()
            .domain([yMin - padding, yMax + padding])
            .range([innerHeight, 0])
            .nice();

        // Create line generator
        const zspreadLineGen = d3.line<{inputdate: Date, value: number}>()
            .x(d => xScale(d.inputdate))
            .y(d => zspreadYScale(d.value))
            .curve(d3.curveMonotoneX);

        // Draw historical data line
        g.append("path")
            .datum(zspreadDiffData)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .attr("d", zspreadLineGen);

        // Draw forecast line if available
        if (this.diffSeriesStationary && allData.length > zspreadDiffData.length) {
            const forecastData = allData.filter((d, i) => 
                i === zspreadDiffData.length - 1 || !d.isHistorical);
            
            g.append("path")
                .datum(forecastData)
                .attr("fill", "none")
                .attr("stroke", "orange")
                .attr("stroke-width", 2)
                .attr("d", zspreadLineGen);
        }

        // Add status text with clearer explanation
        g.append("text")
            .attr("x", innerWidth - 10)
            .attr("y", -10)
            .attr("text-anchor", "end")
            .attr("fill", this.diffSeriesStationary ? "green" : "red")
            .style("font-size", "12px")
            .text(this.diffSeriesStationary ? 
                `Forecast active: When Error changes by 1, Z-Spread changes by ${beta.toFixed(4)}` : 
                "No forecast: Data not suitable for prediction");

        // Add tooltip interaction
        const tooltip = d3.select("#tooltip");
        
        g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mousemove", (event) => {
                const mouseX = xScale.invert(d3.pointer(event)[0]);
                const bisect = d3.bisector<{inputdate: Date, value: number, isHistorical?: boolean}, Date>(
                    d => d.inputdate).left;
                
                // Find closest point
                const index = bisect(allData, mouseX) - 1;
                
                if (index >= 0 && index < allData.length) {
                    const point = allData[index];
                    tooltip
                        .style("opacity", 1)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px")
                        .html(`${point.isHistorical ? 'Historical' : 'Forecast'} Z-Spread Difference:<br/>
                            Date: ${point.inputdate.toLocaleDateString()}<br/>
                            Value: ${point.value.toFixed(4)}`);
                }
            })
            .on("mouseout", () => tooltip.style("opacity", 0));
        
        // Add y-axis
        this.createAxis(g, xScale, zspreadYScale, innerWidth, innerHeight);
    }

    /**
     * Renders the error difference chart with OU process forecast
     */
    private renderStationaryChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        lineGen: d3.Line<DiffPoint>,
        showTooltip: (event: MouseEvent, d: DiffPoint) => void,
        hideTooltip: () => void,
        bisectDate: (arr: DiffPoint[], x: Date) => number,
        innerWidth: number,
        innerHeight: number
    ) {
        const ouResults = this.calculateOUParameters(
            this.diffSeries.map(d => d.diff),
            this.diffSeries.map(d => d.inputdate)
        );

        // Store parameters
        this.lambdaHat = ouResults.lambda;
        this.muHat = ouResults.mu;
        this.sigmaHat = ouResults.sigma;

        // Display parameter info and status text
        g.append("text")
            .attr("x", 10)
            .attr("y", -10)
            .attr("fill", "#333")
            .style("font-size", "12px")
            .text(`μ = ${this.muHat.toFixed(2)}, λ = ${this.lambdaHat.toFixed(2)} (×${this.lambdaSlider.value}), σ = ${this.sigmaHat.toFixed(2)} (×${this.sigmaSlider.value})`);

        g.append("text")
            .attr("x", innerWidth - 10)
            .attr("y", -10)
            .attr("text-anchor", "end")
            .style("fill", "green")
            .style("font-size", "12px")
            .text("ADF passed: Series stationary. OU applied.");

        // Draw charts
        const allPoints = {
            historical: this.diffSeries,
            forecast: ouResults.forecastPoints,
            lowerBound: ouResults.lowerBoundPoints,
            upperBound: ouResults.upperBoundPoints
        };

        // Draw confidence bands
        g.append("path")
            .datum(allPoints.lowerBound)
            .attr("fill", "none")
            .attr("stroke", "grey")
            .attr("stroke-width", 1)
            .style("stroke-dasharray", "3,3")
            .attr("d", lineGen);

        g.append("path")
            .datum(allPoints.upperBound)
            .attr("fill", "none")
            .attr("stroke", "grey")
            .attr("stroke-width", 1)
            .style("stroke-dasharray", "3,3")
            .attr("d", lineGen);

        // Draw forecast and historical lines
        g.append("path")
            .datum(allPoints.forecast)
            .attr("fill", "none")
            .attr("stroke", "orange")
            .attr("stroke-width", 2)
            .attr("d", lineGen);

        g.append("path")
            .datum(allPoints.historical)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .attr("d", lineGen);

        // Add tooltip interaction
        const tooltip = d3.select("#tooltip");
        
        g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mousemove", (event) => {
                const mouseX = xScale.invert(d3.pointer(event)[0]);
                
                // Find closest historical and forecast points
                const histIndex = Math.min(bisectDate(allPoints.historical, mouseX) - 1, 
                    allPoints.historical.length - 1);
                const forecastIndex = Math.min(bisectDate(allPoints.forecast, mouseX) - 1,
                    allPoints.forecast.length - 1);
                
                if (histIndex >= 0 && forecastIndex >= 0) {
                    // Determine if historical or forecast point is closer
                    const histPoint = allPoints.historical[histIndex];
                    const forecastPoint = allPoints.forecast[forecastIndex];
                    const upperPoint = allPoints.upperBound[forecastIndex];
                    const lowerPoint = allPoints.lowerBound[forecastIndex];
                    
                    const histDist = Math.abs(histPoint.inputdate.getTime() - mouseX.getTime());
                    const forecastDist = Math.abs(forecastPoint.inputdate.getTime() - mouseX.getTime());
                    
                    let content;
                    if (histDist < forecastDist) {
                        content = `Historical Data:<br/>
                            Date: ${histPoint.inputdate.toLocaleDateString()}<br/>
                            Value: ${histPoint.diff.toFixed(4)}`;
                    } else {
                        content = `Forecast:<br/>
                            Date: ${forecastPoint.inputdate.toLocaleDateString()}<br/>
                            Value: ${forecastPoint.diff.toFixed(4)}<br/>
                            Upper Bound: ${upperPoint.diff.toFixed(4)}<br/>
                            Lower Bound: ${lowerPoint.diff.toFixed(4)}`;
                    }
                    
                    tooltip
                        .style("opacity", 1)
                        .style("left", `${event.pageX + 10}px`)
                        .style("top", `${event.pageY - 10}px`)
                        .html(content);
                }
            })
            .on("mouseout", hideTooltip);
    }

    /**
     * Renders the error difference chart for non-stationary series (without forecasts)
     */
    private renderNonStationaryChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        lineGen: d3.Line<DiffPoint>,
        showTooltip: (event: MouseEvent, d: DiffPoint) => void,
        hideTooltip: () => void,
        bisectDate: (arr: DiffPoint[], x: Date) => number,
        innerWidth: number,
        innerHeight: number
    ) {
        // Draw historical data line
        g.append("path")
            .datum(this.diffSeries)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .attr("d", lineGen);

        // Add status text
        g.append("text")
            .attr("x", innerWidth - 10)
            .attr("y", -10)
            .attr("text-anchor", "end")
            .style("fill", "red")
            .style("font-size", "12px")
            .text("ADF failed: Series non-stationary. OU not applied.");

        // Add tooltip interaction
        g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mousemove", (event) => {
                const mouseX = xScale.invert(d3.pointer(event)[0]);
                const index = Math.min(Math.max(0, bisectDate(this.diffSeries, mouseX) - 1), 
                    this.diffSeries.length - 1);
                showTooltip(event, this.diffSeries[index]);
            })
            .on("mouseout", hideTooltip);
    }
}
