/**
 * Ornstein-Uhlenbeck Process Forecasting for Bond Error and Z-Spread Differences
 * 
 * See README.md for detailed documentation and usage instructions.
 */

"use strict";
import "./../style/visual.less";
import * as d3 from "d3";
import powerbiVisualsApi from "powerbi-visuals-api";
import IVisual = powerbiVisualsApi.extensibility.visual.IVisual;
import VisualConstructorOptions = powerbiVisualsApi.extensibility.visual.VisualConstructorOptions;
import VisualUpdateOptions = powerbiVisualsApi.extensibility.visual.VisualUpdateOptions;
import DataView = powerbiVisualsApi.DataView;

// Constants
const CHART_MARGINS = { top: 50, right: 40, bottom: 120, left: 70 };
const CHART_SPACING = 50; // Increased spacing between charts
const FORECAST_STEPS = 30;
const ADF_THRESHOLD = -3;
const DEFAULT_LAMBDA = 1.0;
const DEFAULT_SIGMA = 1.0;

/**
 * Interface representing a single row of input data
 */
interface DataRow {
    inputdate: Date;
    context1: string;
    isin1: string;
    isin2: string;
    bond1: string;
    bond2: string;
    error: number;
    zspread_error: number;
    zspread: number; // New column for raw zspread values
}

/**
 * Interface for the difference series points
 */
interface DiffPoint {
    inputdate: Date;
    diff: number;                // error difference
    zspread1: number;            // zspread_error for bond1
    zspread2: number;            // zspread_error for bond2
    zspreadDiff: number;         // zspread_error difference
    zspreadRaw1: number;         // raw zspread for bond1
    zspreadRaw2: number;         // raw zspread for bond2
    zspreadRawDiff: number;      // raw zspread difference
}

/**
 * Interface for OU process parameters and forecasts
 */
interface OUResults {
    lambda: number;
    mu: number;
    sigma: number;
    forecastPoints: DiffPoint[];
    upperBoundPoints: DiffPoint[];
    lowerBoundPoints: DiffPoint[];
}

/**
 * Memoization utility for expensive calculations
 * Stores previously computed results to avoid redundant calculations
 * by caching results based on input arguments
 */
function memoize<T, R>(fn: (arg: T) => R): (arg: T) => R {
    const cache = new Map<string, R>();
    return (arg: T) => {
        const key = JSON.stringify(arg);
        if (cache.has(key)) {
            return cache.get(key)!;
        }
        const result = fn(arg);
        cache.set(key, result);
        return result;
    };
}

export class Visual implements IVisual {
    // DOM Elements
    private target: HTMLElement;
    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;
    private dropdownPairs: HTMLSelectElement;
    private lambdaSlider: HTMLInputElement;
    private sigmaSlider: HTMLInputElement;

    // Data Storage
    private allData: DataRow[] = [];
    private diffSeries: DiffPoint[] = [];

    // Ornstein-Uhlenbeck Parameters
    private lambdaHat: number = 0;
    private muHat: number = 0;
    private sigmaHat: number = 0;
    private delta: number = 1;

    // Viewport Configuration
    private currentViewport: { width: number; height: number } = { width: 600, height: 300 };
    private diffSeriesStationary: boolean = false;
    private beta: number = 0;

    // Add cache for processed data
    private processedData: Map<string, DiffPoint[]> = new Map();

    constructor(options: VisualConstructorOptions) {
        this.initializeVisual(options);
    }

    /**
     * Initializes the visual with controls and event listeners
     */
    private initializeVisual(options: VisualConstructorOptions): void {
        this.target = options.element;
        
        // Clear completely before initializing
        this.target.innerHTML = "";
        
        // Build DOM in a more efficient order
        this.createControlContainer();
        this.createTooltip();
        this.createSVGContainer();
        this.initializeControls();
    }

    /**
     * Creates the control container with dropdown and sliders
     */
    private createControlContainer(): void {
        // Use document fragment for better performance
        const fragment = document.createDocumentFragment();
        const controlContainer = document.createElement("div");
        controlContainer.id = "control-container";
        
        // Create dropdown container
        const dropdownContainer = document.createElement("div");
        dropdownContainer.id = "dropdown-container";
        
        const dropdownLabel = document.createElement("label");
        dropdownLabel.setAttribute("for", "pairDropdown");
        dropdownLabel.textContent = "Select Pair (Bond1 vs Bond2):";
        
        this.dropdownPairs = document.createElement("select");
        this.dropdownPairs.id = "pairDropdown";
        this.dropdownPairs.style.fontSize = "10px";
        
        dropdownContainer.appendChild(dropdownLabel);
        dropdownContainer.appendChild(this.dropdownPairs);
        
        // Create slider container
        const sliderContainer = document.createElement("div");
        sliderContainer.id = "slider-container";
        
        // Lambda slider
        const lambdaContainer = document.createElement("div");
        const lambdaLabel = document.createElement("label");
        lambdaLabel.setAttribute("for", "lambdaSlider");
        lambdaLabel.textContent = "Lambda Factor:";
        
        this.lambdaSlider = document.createElement("input");
        this.lambdaSlider.id = "lambdaSlider";
        this.lambdaSlider.type = "range";
        this.lambdaSlider.min = "0.1";
        this.lambdaSlider.max = "2.0";
        this.lambdaSlider.step = "0.01";
        this.lambdaSlider.value = DEFAULT_LAMBDA.toString();
        
        const lambdaValue = document.createElement("span");
        lambdaValue.id = "lambdaValue";
        lambdaValue.textContent = DEFAULT_LAMBDA.toString();
        
        lambdaContainer.appendChild(lambdaLabel);
        lambdaContainer.appendChild(this.lambdaSlider);
        lambdaContainer.appendChild(lambdaValue);
        
        // Sigma slider
        const sigmaContainer = document.createElement("div");
        const sigmaLabel = document.createElement("label");
        sigmaLabel.setAttribute("for", "sigmaSlider");
        sigmaLabel.textContent = "Sigma Factor:";
        
        this.sigmaSlider = document.createElement("input");
        this.sigmaSlider.id = "sigmaSlider";
        this.sigmaSlider.type = "range";
        this.sigmaSlider.min = "0.1";
        this.sigmaSlider.max = "1.5";
        this.sigmaSlider.step = "0.01";
        this.sigmaSlider.value = DEFAULT_SIGMA.toString();
        
        const sigmaValue = document.createElement("span");
        sigmaValue.id = "sigmaValue";
        sigmaValue.textContent = DEFAULT_SIGMA.toString();
        
        sigmaContainer.appendChild(sigmaLabel);
        sigmaContainer.appendChild(this.sigmaSlider);
        sigmaContainer.appendChild(sigmaValue);
        
        // Assemble slider container
        sliderContainer.appendChild(lambdaContainer);
        sliderContainer.appendChild(sigmaContainer);
        
        // Assemble final control container
        controlContainer.appendChild(dropdownContainer);
        controlContainer.appendChild(sliderContainer);
        fragment.appendChild(controlContainer);
        
        // Single DOM manipulation for better performance
        this.target.appendChild(fragment);
    }

    /**
     * Creates the tooltip element
     */
    private createTooltip(): void {
        const tooltip = document.createElement("div");
        tooltip.id = "tooltip";
        Object.assign(tooltip.style, {
            position: "absolute",
            padding: "8px",
            background: "rgba(255, 255, 255, 0.9)",
            border: "1px solid #ddd",
            borderRadius: "4px",
            pointerEvents: "none",
            fontSize: "12px",
            zIndex: "1000",
            opacity: "0"
        });
        this.target.appendChild(tooltip);
    }

    /**
     * Initializes control elements and event listeners with performance optimizations
     */
    private initializeControls(): void {
        // Use debounced event handlers to prevent excessive rendering
        const debounce = (fn: Function, delay: number) => {
            let timer: number | null = null;
            return (...args: any[]) => {
                if (timer) window.clearTimeout(timer);
                timer = window.setTimeout(() => fn(...args), delay);
            };
        };
        
        // Add event listeners with performance optimizations
        this.dropdownPairs.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
        
        // Use input event for real-time updates on sliders
        this.lambdaSlider.addEventListener("input", () => {
            (document.getElementById("lambdaValue") as HTMLElement).innerText = this.lambdaSlider.value;
        });
        
        // Use change event for rendering only when slider stops (better performance)
        this.lambdaSlider.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
        
        this.sigmaSlider.addEventListener("input", () => {
            (document.getElementById("sigmaValue") as HTMLElement).innerText = this.sigmaSlider.value;
        });
        
        this.sigmaSlider.addEventListener("change", debounce(() => this.updateChartsInner(), 50));
    }

    /**
     * Creates the SVG container for the chart
     */
    private createSVGContainer(): void {
        this.svg = d3.select(this.target)
            .append("svg")
            .classed("ou-estimation-visual", true);
    }

    /**
     * Parses a single row of data with validation
     */
    private parseDataRow(row: any[]): DataRow | null {
        let dateVal: Date;
        if (row[0] instanceof Date) {
            dateVal = row[0];
        } else if (typeof row[0] === 'string') {
            dateVal = new Date(row[0]);
            if (isNaN(dateVal.getTime())) return null;
        } else if (typeof row[0] === 'number') {
            dateVal = new Date(row[0]);
        } else {
            return null;
        }

        return {
            inputdate: dateVal,
            context1: row[1]?.toString() || "",
            isin1: row[2]?.toString() || "",
            isin2: row[3]?.toString() || "",
            bond1: row[4]?.toString() || "",
            bond2: row[5]?.toString() || "",
            error: +row[6],
            zspread_error: +row[7] || 0,
            zspread: +row[8] || 0  // New field for raw zspread values
        };
    }

    /**
     * Resets sliders to default values
     */
    private resetSliders(): void {
        this.lambdaSlider.value = DEFAULT_LAMBDA.toString();
        this.sigmaSlider.value = DEFAULT_SIGMA.toString();
        (document.getElementById("lambdaValue") as HTMLElement).innerText = DEFAULT_LAMBDA.toString();
        (document.getElementById("sigmaValue") as HTMLElement).innerText = DEFAULT_SIGMA.toString();
    }

    public update(options: VisualUpdateOptions) {
        const dataView: DataView = options.dataViews?.[0];
        if (!dataView?.table) return;
        
        this.currentViewport = options.viewport || { width: 600, height: 300 };
        this.resetSliders();

        const rows = dataView.table.rows;
        if (!rows?.length) return;

        // Parse and sort data
        this.allData = rows
            .map(row => this.parseDataRow(row))
            .filter((row): row is DataRow => row !== null)
            .sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());

        // Update dropdown with latest P_VALUE rows
        this.updateDropdown();
        
        // Update chart if data is available
        if (this.allData.length > 0) {
            this.updateChartsInner();
        }
    }

    /**
     * Updates the dropdown with the latest P_VALUE rows
     * 
     * This method filters the most recent P_VALUE entries and populates
     * the dropdown with unique bond pairs for selection
     */
    private updateDropdown(): void {
        // Filter rows with context1 = "P_VALUE"
        const pValueRows = this.allData.filter(d => 
            d.context1.trim().toUpperCase() === "P_VALUE"
        );

        if (pValueRows.length === 0) {
            this.dropdownPairs.options.length = 0;
            this.svg.selectAll("*").remove();
            return;
        }

        // Find the most recent date in the P_VALUE rows
        const maxDate = d3.max(pValueRows, d => d.inputdate.getTime())!;
        const latestRows = pValueRows.filter(d => 
            d.inputdate.toDateString() === new Date(maxDate).toDateString()
        );

        const uniquePairs = Array.from(new Set(
            latestRows.map(row => `${row.bond1} vs ${row.bond2}`)
        ));

        this.dropdownPairs.options.length = 0;
        uniquePairs.forEach(pair => {
            const opt = document.createElement("option");
            opt.value = pair;
            opt.text = pair;
            opt.style.fontSize = "10px";
            this.dropdownPairs.appendChild(opt);
        });

        if (uniquePairs.length > 0) {
            this.dropdownPairs.value = uniquePairs[0];
        }
    }

    /**
     * Core method to update charts based on the selected bond pair
     * 
     * This method:
     * 1. Calculates differences between bond values (error, zspread_error, zspread)
     * 2. Tests for stationarity using the ADF test
     * 3. Computes the regression coefficient between zspread and zspread_error
     * 4. Generates forecasts based on the Ornstein-Uhlenbeck process
     */
    private updateChartsInner() {
        if (this.dropdownPairs.options.length === 0) return;
        
        const selectedPair = this.dropdownPairs.value;
        if (!selectedPair) return;
        
        // Parse selected bond pair
        const [selectedBond1, selectedBond2] = selectedPair.split(" vs ");

        // Use caching for processed data to improve performance
        const cacheKey = `${selectedBond1}_${selectedBond2}_${this.allData.length}`;
        if (this.processedData.has(cacheKey)) {
            this.diffSeries = this.processedData.get(cacheKey)!;
        } else {
            // Filter and compute difference series for both error and zspread metrics
            const errorRows = this.allData.filter(d => 
                d.context1.trim().toUpperCase() === "ERROR" &&
                (d.bond1.trim() === selectedBond1.trim() || d.bond1.trim() === selectedBond2.trim())
            );
    
            // Use Map for faster lookups instead of repeated array searches
            // Store error, zspread_error, and zspread values for each bond by date
            const mapBond1 = new Map<string, {error: number, zspread_error: number, zspread: number}>();
            const mapBond2 = new Map<string, {error: number, zspread_error: number, zspread: number}>();
            
            // Process data more efficiently with a single loop
            errorRows.forEach(d => {
                const key = d.inputdate.toDateString();
                const value = { 
                    error: d.error, 
                    zspread_error: d.zspread_error,
                    zspread: d.zspread
                };
                
                if (d.bond1.trim() === selectedBond1.trim()) {
                    mapBond1.set(key, value);
                } else if (d.bond1.trim() === selectedBond2.trim()) {
                    mapBond2.set(key, value);
                }
            });
    
            // Compute difference series in a single pass
            // For each date where both bonds have data, calculate:
            // 1. Error difference (diff)
            // 2. Z-spread error differences (zspreadDiff)
            // 3. Raw Z-spread differences (zspreadRawDiff)
            this.diffSeries = [];
            mapBond1.forEach((val1, key) => {
                if (mapBond2.has(key)) {
                    const val2 = mapBond2.get(key)!;
                    this.diffSeries.push({
                        inputdate: new Date(key),
                        // Calculate bond2 minus bond1 for each metric
                        diff: val2.error - val1.error,
                        zspread1: val1.zspread_error,
                        zspread2: val2.zspread_error,
                        zspreadDiff: val2.zspread_error - val1.zspread_error,
                        zspreadRaw1: val1.zspread,
                        zspreadRaw2: val2.zspread,
                        zspreadRawDiff: val2.zspread - val1.zspread
                    });
                }
            });
            
            // Sort chronologically
            this.diffSeries.sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());
            
            // Cache the processed data for future use
            this.processedData.set(cacheKey, this.diffSeries);
        }

        if (this.diffSeries.length < 2) {
            this.renderChart(false);
            return;
        }

        // Calculate beta coefficient for the regression between zspread and zspread_error
        const { alpha, beta } = this.calculateBeta();

        // Apply Augmented Dickey-Fuller test to check for stationarity
        // This determines whether we can use the OU process for forecasting
        const diffs = this.diffSeries.map(d => d.diff);
        this.diffSeriesStationary = this.performADFTest(diffs);
        this.renderChart(this.diffSeriesStationary);
    }

    /**
     * Calculates the beta coefficient for the relationship between 
     * raw zspread differences and zspread_error differences
     * 
     * The relationship is modeled as:
     * zspread_error_diff = β × zspread_diff
     * 
     * This is a proportional relationship (forced through origin) without an intercept term (α).
     * The beta coefficient represents how changes in raw zspread translate to 
     * changes in zspread_error.
     * 
     * This approach is different from standard OLS regression as we're specifically
     * setting alpha=0 to get a pure proportional relationship.
     */
    private calculateBeta(): { alpha: number, beta: number } {
        if (this.diffSeries.length < 2) return { alpha: 0, beta: 0 };

        // Calculate means for zspread raw difference and z-spread error difference
        const zspreadRawMean = d3.mean(this.diffSeries, d => d.zspreadRawDiff) || 0;
        const zspreadErrorMean = d3.mean(this.diffSeries, d => d.zspreadDiff) || 0;

        // Calculate linear regression coefficient β (slope only)
        // Using formula: β = Cov(X,Y)/Var(X)
        // Where X is zspreadRawDiff and Y is zspreadDiff
        let numerator = 0;   // Covariance between zspread_diff and zspread_error_diff
        let denominator = 0; // Variance of zspread_diff
        
        this.diffSeries.forEach(d => {
            const zspreadRawDev = d.zspreadRawDiff - zspreadRawMean;         // Deviation from mean for zspread diff
            const zspreadErrorDev = d.zspreadDiff - zspreadErrorMean;        // Deviation from mean for zspread error diff
            numerator += zspreadRawDev * zspreadErrorDev;                    // Sum of products for covariance
            denominator += zspreadRawDev * zspreadRawDev;                    // Sum of squares for variance
        });

        // Calculate beta (slope coefficient)
        // If denominator is zero (no variance in X), return zero to avoid division by zero
        const beta = denominator !== 0 ? numerator / denominator : 0;
        
        // Set alpha to 0 as requested (don't use intercept for forecasting)
        // This creates a proportional relationship: Y = βX
        const alpha = 0;

        return { alpha, beta };
    }

    // Update the ADF test implementation with better comments
    private performADFTest = memoize((data: number[]): boolean => {
        if (data.length < 3) return false;
        
        // ADF test equation: Δy_t = α + βy_{t-1} + ε_t
        // where β = ρ - 1 and ρ is the autoregressive coefficient
        
        // Create first difference series (Δy_t)
        const dX = data.slice(1).map((val, i) => val - data[i]);
        // Create lagged series (y_{t-1})
        const lagX = data.slice(0, -1);
        
        // Calculate means for demeaning
        const meanLag = d3.mean(lagX)!;
        const meanDX = d3.mean(dX)!;
        
        // Calculate numerator for the slope coefficient: Σ(y_{t-1} - mean_y)(Δy_t - mean_Δy)
        const num = dX.reduce((sum, val, i) => 
            sum + (lagX[i] - meanLag) * (val - meanDX), 0);
        // Calculate denominator: Σ(y_{t-1} - mean_y)²
        const den = lagX.reduce((sum, val) => 
            sum + Math.pow(val - meanLag, 2), 0);
            
        // Calculate slope coefficient β
        const slope = num / den;
        
        // Calculate sum of squared residuals for standard error
        const ssr = dX.reduce((sum, val, i) => 
            sum + Math.pow(val - slope * lagX[i], 2), 0);
            
        // Calculate variance of residuals
        const s2 = ssr / (dX.length - 2);
        // Calculate standard error of slope coefficient
        const se = Math.sqrt(s2 / den);
        // Calculate t-statistic (Dickey-Fuller test statistic)
        const tStat = slope / se;
        
        // Compare against critical value ADF_THRESHOLD (typically -3)
        // If t-statistic < threshold, reject null hypothesis of unit root (non-stationarity)
        return tStat < ADF_THRESHOLD;
    });

    // Add detailed comments to OU parameter estimation
    private calculateOUParameters(diffValues: number[], dates: Date[]): OUResults {
        // Only compute when we have enough data
        if (diffValues.length < 2) {
            return {
                lambda: 0,
                mu: 0,
                sigma: 0,
                forecastPoints: [],
                upperBoundPoints: [],
                lowerBoundPoints: []
            };
        }
        
        const n = diffValues.length - 1;
        // Calculate long-term mean (μ) estimate
        const diffMean = d3.mean(diffValues)!;
        
        // Calculate time parameters
        // Total time span in milliseconds
        const totalTimeSpan = (dates[dates.length - 1].getTime() - dates[0].getTime());
        // Average time step between observations
        const delta = totalTimeSpan / n;
        // Convert to days for more intuitive lambda parameter
        const deltaDays = delta / (1000 * 60 * 60 * 24);
        
        // Precalculate deviations to avoid repeated calculations
        const deviations = diffValues.map(val => val - diffMean);
        
        // Calculate auto-correlation coefficient (α) using demeaned values
        // In OU process, α = e^(-λΔt) where Δt is time step
        let num = 0;
        let den = 0;
        for (let i = 0; i < n; i++) {
            num += deviations[i+1] * deviations[i];  // Covariance between X_t and X_{t+1}
            den += deviations[i] * deviations[i];    // Variance of X_t
        }
        // Bound alpha to prevent numerical issues
        let alphaHat = Math.max(Math.min(num / den, 0.9999999), -0.9999999);

        // Calculate mean reversion rate (λ)
        // From α = e^(-λΔt), we get λ = -ln(α)/Δt
        const lambdaHat = -Math.log(alphaHat) / deltaDays;
        
        // Calculate long-term mean (μ) using residuals
        // For OU process discrete form: X_{t+1} = μ(1-α) + αX_t + ε_t
        // Rearranging: X_{t+1} - αX_t = μ(1-α) + ε_t
        let sumResidual = 0;
        for (let i = 0; i < n; i++) {
            sumResidual += diffValues[i+1] - alphaHat * diffValues[i];
        }
        const muHat = sumResidual / (n * (1 - alphaHat));

        // Calculate volatility (σ) using residuals from the model
        // ε_t = X_{t+1} - μ(1-α) - αX_t
        let sumSq = 0;
        for (let i = 0; i < n; i++) {
            const r = diffValues[i+1] - alphaHat * diffValues[i] - (1 - alphaHat) * muHat;
            sumSq += r * r;
        }
        // Using relationship between discrete and continuous time parameters
        // σ²_continuous = 2λσ²_discrete/(1-α²) where σ²_discrete = Var(ε_t)
        const sigmaSqHat = (2 * lambdaHat) / (1 - alphaHat * alphaHat) * (1 / n) * sumSq;
        const sigmaHat = Math.sqrt(Math.max(sigmaSqHat, 0));

        // Apply user-adjustable scaling factors for sensitivity analysis
        const lambdaFactor = parseFloat(this.lambdaSlider.value);
        const sigmaFactor = parseFloat(this.sigmaSlider.value);
        const newLambda = lambdaHat * lambdaFactor;
        const newSigma = sigmaHat * sigmaFactor;
        
        // Calculate discrete-time alpha with adjusted lambda
        const alpha = Math.exp(-newLambda * deltaDays);

        // Generate forecast points based on OU process
        // For OU process, E[X_t | X_0 = x_0] = μ + (x_0 - μ)e^(-λt)
        const lastDiff = diffValues[diffValues.length - 1];
        const lastTime = dates[dates.length - 1].getTime();
        
        const forecastPoints: DiffPoint[] = [];
        const upperBoundPoints: DiffPoint[] = [];
        const lowerBoundPoints: DiffPoint[] = [];

        // Create forecast points in a single loop
        for (let i = 0; i <= FORECAST_STEPS; i++) {
            const nextDate = new Date(lastTime + i * delta);
            const alphaPow = Math.pow(alpha, i);
            
            // Mean forecast: E[X_t | X_0] = μ + (X_0 - μ)e^(-λt)
            const meanForecast = muHat + (lastDiff - muHat) * alphaPow;
            
            // Variance forecast: Var[X_t | X_0] = (σ²/2λ)(1 - e^(-2λt))
            const varForecast = (newSigma * newSigma) / (2 * newLambda) * (1 - Math.pow(alpha, 2 * i));
            const stdDev = Math.sqrt(varForecast);
            
            // Create forecast points (main, upper 95% CI, lower 95% CI)
            forecastPoints.push({ 
                inputdate: nextDate, 
                diff: meanForecast, 
                zspread1: 0, 
                zspread2: 0, 
                zspreadDiff: 0,
                zspreadRaw1: 0,
                zspreadRaw2: 0,
                zspreadRawDiff: 0 
            });
            
            // Upper bound: mean + 1.96*std (95% confidence interval)
            upperBoundPoints.push({ 
                inputdate: nextDate, 
                diff: meanForecast + 1.96 * stdDev, 
                zspread1: 0, 
                zspread2: 0, 
                zspreadDiff: 0,
                zspreadRaw1: 0,
                zspreadRaw2: 0,
                zspreadRawDiff: 0 
            });
            
            // Lower bound: mean - 1.96*std (95% confidence interval)
            lowerBoundPoints.push({ 
                inputdate: nextDate, 
                diff: meanForecast - 1.96 * stdDev, 
                zspread1: 0, 
                zspread2: 0, 
                zspreadDiff: 0,
                zspreadRaw1: 0,
                zspreadRaw2: 0,
                zspreadRawDiff: 0
            });
        }

        return {
            lambda: newLambda,
            mu: muHat,
            sigma: newSigma,
            forecastPoints,
            upperBoundPoints,
            lowerBoundPoints
        };
    }

    // Add utility methods for common chart operations
    private createChartElements(width: number, height: number, chartWidth: number, innerHeight: number) {
        // Clear previous chart
        this.svg.selectAll("*").remove();
        this.svg.attr("width", width).attr("height", height);

        // Create main chart group for error chart
        const errorChart = this.svg.append("g")
            .attr("transform", `translate(${CHART_MARGINS.left}, ${CHART_MARGINS.top})`);

        // Create second chart group for zspread chart
        const zspreadChart = this.svg.append("g")
            .attr("transform", `translate(${CHART_MARGINS.left + chartWidth + CHART_SPACING}, ${CHART_MARGINS.top})`);

        return { errorChart, zspreadChart };
    }

    private createAxis(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        innerWidth: number,
        innerHeight: number
    ) {
        // Create x-axis with adaptive tick count based on available width
        const tickCount = Math.max(2, Math.floor(innerWidth / 100));
        const xAxis = d3.axisBottom(xScale)
            .ticks(tickCount)
            .tickFormat(d3.timeFormat("%b %d, %Y"));
            
        const xAxisGroup = g.append("g")
            .attr("transform", `translate(0, ${innerHeight})`)
            .call(xAxis);

        // Style x-axis text labels
        xAxisGroup.selectAll("text")
            .attr("transform", "rotate(-20)")
            .style("text-anchor", "end")
            .style("font-size", "10px")
            .style("fill", "#666")
            .attr("dy", "1em")
            .attr("dx", "-0.5em");

        // Style x-axis lines and path
        xAxisGroup.selectAll("line, path")
            .style("stroke", "#ddd")
            .style("stroke-width", "1px");

        // Create and style y-axis with 5 ticks
        const yAxis = d3.axisLeft(yScale).ticks(5);
        const yAxisGroup = g.append("g").call(yAxis);

        // Style y-axis text labels
        yAxisGroup.selectAll("text")
            .style("font-size", "10px")
            .style("fill", "#666");

        // Style y-axis lines and path
        yAxisGroup.selectAll("line, path")
            .style("stroke", "#ddd")
            .style("stroke-width", "1px");
    }

    /**
     * Main chart rendering method
     * 
     * Orchestrates the rendering of both charts:
     * 1. Error difference chart with OU process forecasts
     * 2. Z-spread error difference chart with beta-based forecasts
     * 
     * The rendering approach depends on whether the series is stationary,
     * which determines if forecasting can be applied.
     */
    private renderChart(isStationary: boolean) {
        // Set up dimensions for two charts side by side
        const width = this.currentViewport.width;
        const height = this.currentViewport.height;
        const totalWidth = width - CHART_MARGINS.left - CHART_MARGINS.right;
        const chartWidth = (totalWidth - CHART_SPACING) / 2;
        const innerHeight = height - CHART_MARGINS.top - CHART_MARGINS.bottom;

        // Create chart elements
        const { errorChart, zspreadChart } = this.createChartElements(width, height, chartWidth, innerHeight);

        // Add error chart title
        errorChart.append("text")
            .attr("x", 10)
            .attr("y", -35)
            .attr("text-anchor", "start")
            .style("font-size", "14px")
            .style("font-weight", "bold")
            .style("font-family", "Arial, sans-serif")
            .style("fill", "#00818F")
            .text("Error Difference");

        // Check for data
        if (this.diffSeries.length < 1) {
            errorChart.append("text")
                .attr("x", chartWidth / 2)
                .attr("y", innerHeight / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "red")
                .style("font-size", "14px")
                .text("No data to display.");
            return;
        }

        // Create scales and line generator for error chart
        const { xScale, yScale } = this.createScales(isStationary, chartWidth, innerHeight);
        const lineGen = d3.line<DiffPoint>()
            .x(d => xScale(d.inputdate))
            .y(d => yScale(d.diff))
            .curve(d3.curveMonotoneX);

        // Create tooltip behavior
        const tooltip = d3.select("#tooltip");
        const bisectDate = d3.bisector<DiffPoint, Date>(d => d.inputdate).left;

        const showTooltip = (event: MouseEvent, d: DiffPoint) => {
            tooltip
                .style("opacity", 1)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px")
                .html(`Date: ${d.inputdate.toLocaleDateString()}<br/>Value: ${d.diff.toFixed(4)}`);
        };

        const hideTooltip = () => {
            tooltip.style("opacity", 0);
        };

        // Render appropriate chart based on stationarity
        if (isStationary) {
            this.renderStationaryChart(errorChart, xScale, yScale, lineGen, showTooltip, hideTooltip, bisectDate, chartWidth, innerHeight);
        } else {
            this.renderNonStationaryChart(errorChart, xScale, yScale, lineGen, showTooltip, hideTooltip, bisectDate, chartWidth, innerHeight);
        }

        // Render Z-spread chart
        this.renderZspreadChart(zspreadChart, xScale, yScale, chartWidth, innerHeight);

        // Add axes to both charts
        this.createAxis(errorChart, xScale, yScale, chartWidth, innerHeight);
        this.createAxis(zspreadChart, xScale, yScale, chartWidth, innerHeight);
    }

    /**
     * Creates scales for the charts based on data and stationarity
     * 
     * For stationary series, the scales include both historical and forecast data.
     * For non-stationary series, only historical data is used.
     */
    private createScales(isStationary: boolean, innerWidth: number, innerHeight: number) {
        let xScale: d3.ScaleTime<number, number>;
        let yScale: d3.ScaleLinear<number, number>;

        if (isStationary) {
            // For stationary series, calculate OU parameters and include forecast range
            const ouResults = this.calculateOUParameters(
                this.diffSeries.map(d => d.diff),
                this.diffSeries.map(d => d.inputdate)
            );

            // Combine historical and forecast data points for domain calculation
            const allX = this.diffSeries.map(d => d.inputdate)
                .concat(ouResults.forecastPoints.map(d => d.inputdate));
            
            // Include confidence bounds in y-domain calculation
            const allY = this.diffSeries.map(d => d.diff)
                .concat(ouResults.forecastPoints.map(d => d.diff))
                .concat(ouResults.upperBoundPoints.map(d => d.diff))
                .concat(ouResults.lowerBoundPoints.map(d => d.diff));

            // Create time scale for x-axis
            xScale = d3.scaleTime()
                .domain([d3.min(allX) as Date, d3.max(allX) as Date])
                .range([0, innerWidth]);

            // Create linear scale for y-axis with nice rounding
            yScale = d3.scaleLinear()
                .domain([d3.min(allY) as number, d3.max(allY) as number])
                .range([innerHeight, 0])
                .nice();
        } else {
            // For non-stationary series, use only historical data
            xScale = d3.scaleTime()
                .domain([
                    d3.min(this.diffSeries, d => d.inputdate)!,
                    d3.max(this.diffSeries, d => d.inputdate)!
                ])
                .range([0, innerWidth]);

            yScale = d3.scaleLinear()
                .domain([
                    d3.min(this.diffSeries, d => d.diff) as number,
                    d3.max(this.diffSeries, d => d.diff) as number
                ])
                .range([innerHeight, 0])
                .nice();
        }

        return { xScale, yScale };
    }

    /**
     * Renders the zspread chart showing historical zspread_error differences
     * and forecasted values based on the β coefficient
     * 
     * The forecast approach:
     * 1. First forecasts raw zspread differences using the OU process
     * 2. Then calculates zspread_error forecasts using the simple formula:
     *    zspread_error_diff = β × zspread_diff
     * 
     * This approach enforces a proportional relationship between
     * raw zspread and zspread_error, without an intercept term.
     */
    private renderZspreadChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        innerWidth: number,
        innerHeight: number
    ) {
        // Clear any existing content
        g.selectAll("*").remove();

        // Add Z-Spread Error chart title
        g.append("text")
            .attr("x", 10)
            .attr("y", -35)
            .attr("text-anchor", "start")
            .style("font-size", "14px")
            .style("font-weight", "bold")
            .style("font-family", "Arial, sans-serif")
            .style("fill", "#00818F")
            .text("Z-Spread Error Difference (β × Z-Spread only)");

        // Extract data for plotting - both historical series
        const zspreadErrorDiffData = this.diffSeries.map(d => ({
            inputdate: d.inputdate,
            value: d.zspreadDiff      // Historical zspread_error differences
        }));
        
        const zspreadRawDiffData = this.diffSeries.map(d => ({
            inputdate: d.inputdate,
            value: d.zspreadRawDiff   // Historical raw zspread differences
        }));

        if (zspreadErrorDiffData.length === 0) {
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#666")
                .text("No zspread data available");
            return;
        }

        // Get beta coefficient for the proportional relationship
        const { alpha, beta } = this.calculateBeta();
        this.beta = beta; // Store beta for display

        // Prepare arrays for forecast data points
        let forecastZspreadRawData: {inputdate: Date, value: number}[] = [];
        let forecastZspreadErrorData: {inputdate: Date, value: number}[] = [];
        
        if (this.diffSeriesStationary) {
            // Get OU parameters and forecasts for the error series
            const ouResults = this.calculateOUParameters(
                this.diffSeries.map(d => d.diff),
                this.diffSeries.map(d => d.inputdate)
            );
            
            // Step 1: Forecast raw zspread differences using the OU process
            // We apply the same mean-reversion pattern to zspread as we do to errors
            forecastZspreadRawData = ouResults.forecastPoints.map((forecastPoint, i) => {
                // Get the last observed value and the mean
                const lastZspreadRawDiff = this.diffSeries[this.diffSeries.length - 1].zspreadRawDiff;
                const zspreadRawMean = d3.mean(this.diffSeries, d => d.zspreadRawDiff) || 0;
                
                // Calculate the decay factor for the i-th forecast step
                // This is e^(-λΔt) where Δt is the time step in days
                const alphaPow = Math.pow(Math.exp(-ouResults.lambda * this.delta / (1000 * 60 * 60 * 24)), i);
                
                // OU forecast formula: μ + (X_last - μ) * e^(-λt)
                // This represents mean reversion, where the forecast starts at the last value
                // and gradually reverts toward the mean at a rate determined by lambda
                const zspreadRawForecast = zspreadRawMean + (lastZspreadRawDiff - zspreadRawMean) * alphaPow;
                
                return {
                    inputdate: forecastPoint.inputdate,
                    value: zspreadRawForecast
                };
            });
            
            // Step 2: Calculate zspread_error forecasts using the proportional relationship
            // zspread_error_diff = β × zspread_diff
            forecastZspreadErrorData = forecastZspreadRawData.map(rawForecast => {
                // Apply only beta: zspread_error_diff = β * zspread_diff
                // We explicitly set alpha to 0 to force the line through the origin
                const zspreadErrorForecast = beta * rawForecast.value;
                
                return {
                    inputdate: rawForecast.inputdate,
                    value: zspreadErrorForecast
                };
            });
        }

        // Display the beta coefficient and explain the relationship
        g.append("text")
            .attr("x", 10)
            .attr("y", -10)
            .attr("fill", "#333")
            .style("font-size", "12px")
            .text(`β = ${beta.toFixed(4)} (zspread_error = β × zspread)`);

        // Create scales for the chart - combine historical and forecast data for domain calculation
        const dataForScales = this.diffSeriesStationary ? 
            [...zspreadErrorDiffData, ...forecastZspreadErrorData] : zspreadErrorDiffData;

        // Time scale for x-axis
        const zspreadXScale = d3.scaleTime()
            .domain([
                d3.min(dataForScales, d => d.inputdate)!,
                d3.max(dataForScales, d => d.inputdate)!
            ])
            .range([0, innerWidth]);

        // Linear scale for y-axis
        const zspreadYScale = d3.scaleLinear()
            .domain([
                d3.min(dataForScales, d => d.value)!,
                d3.max(dataForScales, d => d.value)!
            ])
            .range([innerHeight, 0])
            .nice();

        // Create line generator for smooth curves
        const zspreadLineGen = d3.line<{inputdate: Date, value: number}>()
            .x(d => zspreadXScale(d.inputdate))
            .y(d => zspreadYScale(d.value))
            .curve(d3.curveMonotoneX);  // Use monotone interpolation for smoother lines

        // Draw historical zspread_error line
        g.append("path")
            .datum(zspreadErrorDiffData)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .style("stroke-dasharray", "0")
            .attr("d", zspreadLineGen);

        // Draw forecast line if we have stationary data
        if (this.diffSeriesStationary && forecastZspreadErrorData.length > 0) {
            // Combine the last historical point with forecast points for a continuous line
            const combinedData = [zspreadErrorDiffData[zspreadErrorDiffData.length - 1], ...forecastZspreadErrorData];
            g.append("path")
                .datum(combinedData)
                .attr("fill", "none")
                .attr("stroke", "orange")
                .attr("stroke-width", 2)
                .style("stroke-dasharray", "0")
                .attr("d", zspreadLineGen);
        }

        // Add status text to show whether forecasting was possible
        g.append("text")
            .attr("x", innerWidth - 10)
            .attr("y", -10)
            .attr("text-anchor", "end")
            .attr("fill", this.diffSeriesStationary ? "green" : "red")
            .style("font-size", "12px")
            .text(this.diffSeriesStationary ? 
                "β-only forecast applied" : 
                "Series non-stationary. No forecast.");

        // Add tooltip interaction
        const tooltip = d3.select("#tooltip");
        g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mousemove", (event) => {
                // Extract mouse position and convert to date
                const mouseX = zspreadXScale.invert(d3.pointer(event)[0]);
                // Create bisector function to find closest point to mouse position
                const bisect = d3.bisector<{inputdate: Date, value: number}, Date>(d => d.inputdate).left;
                
                // Find nearest points in historical and forecast data
                const histIndex = bisect(zspreadErrorDiffData, mouseX);
                const histPoint = zspreadErrorDiffData[histIndex];
                
                let tooltipContent = "";
                
                if (this.diffSeriesStationary && forecastZspreadErrorData.length > 0) {
                    const forecastIndex = bisect(forecastZspreadErrorData, mouseX);
                    const forecastPoint = forecastZspreadErrorData[forecastIndex];
                    
                    // Determine whether to show historical or forecast data in tooltip
                    // based on which point is closer to the mouse
                    if (histPoint && forecastPoint) {
                        const histDist = Math.abs(histPoint.inputdate.getTime() - mouseX.getTime());
                        const forecastDist = Math.abs(forecastPoint.inputdate.getTime() - mouseX.getTime());
                        
                        if (histDist < forecastDist) {
                            tooltipContent = `Historical Z-Spread Error Difference:<br/>
                                Date: ${histPoint.inputdate.toLocaleDateString()}<br/>
                                Value: ${histPoint.value.toFixed(4)}`;
                        } else {
                            tooltipContent = `Forecast Z-Spread Error (β × Z-Spread):<br/>
                                Date: ${forecastPoint.inputdate.toLocaleDateString()}<br/>
                                Value: ${forecastPoint.value.toFixed(4)}`;
                        }
                    } else if (histPoint) {
                        tooltipContent = `Historical Z-Spread Error Difference:<br/>
                            Date: ${histPoint.inputdate.toLocaleDateString()}<br/>
                            Value: ${histPoint.value.toFixed(4)}`;
                    } else if (forecastPoint) {
                        tooltipContent = `Forecast Z-Spread Error (β × Z-Spread):<br/>
                            Date: ${forecastPoint.inputdate.toLocaleDateString()}<br/>
                            Value: ${forecastPoint.value.toFixed(4)}`;
                    }
                } else if (histPoint) {
                    tooltipContent = `Historical Z-Spread Error Difference:<br/>
                        Date: ${histPoint.inputdate.toLocaleDateString()}<br/>
                        Value: ${histPoint.value.toFixed(4)}`;
                }

                // Display tooltip if we have content
                if (tooltipContent) {
                    tooltip
                        .style("opacity", 1)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px")
                        .html(tooltipContent);
                }
            })
            .on("mouseout", () => tooltip.style("opacity", 0));
    }

    private renderStationaryChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        lineGen: d3.Line<DiffPoint>,
        showTooltip: (event: MouseEvent, d: DiffPoint) => void,
        hideTooltip: () => void,
        bisectDate: (arr: DiffPoint[], x: Date) => number,
        innerWidth: number,
        innerHeight: number
    ) {
        const ouResults = this.calculateOUParameters(
            this.diffSeries.map(d => d.diff),
            this.diffSeries.map(d => d.inputdate)
        );

        // Store parameters
        this.lambdaHat = ouResults.lambda;
        this.muHat = ouResults.mu;
        this.sigmaHat = ouResults.sigma;

        // Display parameter estimates
        g.append("text")
            .attr("x", 10)
            .attr("y", -10)
            .attr("fill", "#333")
            .style("font-size", "12px")
            .text(`μ = ${this.muHat.toFixed(2)}, λ = ${this.lambdaHat.toFixed(2)} (×${this.lambdaSlider.value}), σ = ${this.sigmaHat.toFixed(2)} (×${this.sigmaSlider.value})`);

        // Add status text
        g.append("text")
            .attr("x", innerWidth - 10)
            .attr("y", -10)
            .attr("text-anchor", "end")
            .style("fill", "green")
            .style("font-size", "12px")
            .text("ADF passed: Series stationary. OU applied.");

        // Draw forecast confidence bands
        g.append("path")
            .datum(ouResults.lowerBoundPoints)
            .attr("fill", "none")
            .attr("stroke", "grey")
            .attr("stroke-width", 1)
            .style("stroke-dasharray", "3,3")
            .attr("d", lineGen);

        g.append("path")
            .datum(ouResults.upperBoundPoints)
            .attr("fill", "none")
            .attr("stroke", "grey")
            .attr("stroke-width", 1)
            .style("stroke-dasharray", "3,3")
            .attr("d", lineGen);

        // Draw forecast mean line
        g.append("path")
            .datum(ouResults.forecastPoints)
            .attr("fill", "none")
            .attr("stroke", "orange")
            .attr("stroke-width", 2)
            .style("stroke-dasharray", "0")
            .attr("d", lineGen);

        // Draw historical data line
        g.append("path")
            .datum(this.diffSeries)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .style("stroke-dasharray", "0")
            .attr("d", lineGen);

        // Add tooltip interaction overlay for the entire chart area
        const overlay = g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mousemove", (event) => {
                const mouseX = xScale.invert(d3.pointer(event)[0]);
                
                // Find the closest point in historical data
                const histIndex = bisectDate(this.diffSeries, mouseX);
                const histPoint = this.diffSeries[histIndex];
                
                // Find the closest point in forecast data
                const forecastIndex = bisectDate(ouResults.forecastPoints, mouseX);
                const forecastPoint = ouResults.forecastPoints[forecastIndex];
                
                // Find the closest points in upper and lower bounds
                const upperPoint = ouResults.upperBoundPoints[forecastIndex];
                const lowerPoint = ouResults.lowerBoundPoints[forecastIndex];

                // Determine which point to show based on which is closer to the mouse
                let tooltipContent = "";
                
                if (histPoint && forecastPoint) {
                    const histDist = Math.abs(histPoint.inputdate.getTime() - mouseX.getTime());
                    const forecastDist = Math.abs(forecastPoint.inputdate.getTime() - mouseX.getTime());
                    
                    if (histDist < forecastDist) {
                        tooltipContent = `Historical Data:<br/>
                            Date: ${histPoint.inputdate.toLocaleDateString()}<br/>
                            Value: ${histPoint.diff.toFixed(4)}`;
                    } else {
                        tooltipContent = `Forecast:<br/>
                            Date: ${forecastPoint.inputdate.toLocaleDateString()}<br/>
                            Value: ${forecastPoint.diff.toFixed(4)}<br/>
                            Upper Bound: ${upperPoint.diff.toFixed(4)}<br/>
                            Lower Bound: ${lowerPoint.diff.toFixed(4)}`;
                    }
                } else if (histPoint) {
                    tooltipContent = `Historical Data:<br/>
                        Date: ${histPoint.inputdate.toLocaleDateString()}<br/>
                        Value: ${histPoint.diff.toFixed(4)}`;
                } else if (forecastPoint) {
                    tooltipContent = `Forecast:<br/>
                        Date: ${forecastPoint.inputdate.toLocaleDateString()}<br/>
                        Value: ${forecastPoint.diff.toFixed(4)}<br/>
                        Upper Bound: ${upperPoint.diff.toFixed(4)}<br/>
                        Lower Bound: ${lowerPoint.diff.toFixed(4)}`;
                }

                if (tooltipContent) {
                    const tooltip = d3.select("#tooltip");
                    tooltip
                        .style("opacity", 1)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px")
                        .html(tooltipContent);
                }
            })
            .on("mouseout", hideTooltip);
    }

    private renderNonStationaryChart(
        g: d3.Selection<SVGGElement, unknown, null, undefined>,
        xScale: d3.ScaleTime<number, number>,
        yScale: d3.ScaleLinear<number, number>,
        lineGen: d3.Line<DiffPoint>,
        showTooltip: (event: MouseEvent, d: DiffPoint) => void,
        hideTooltip: () => void,
        bisectDate: (arr: DiffPoint[], x: Date) => number,
        innerWidth: number,
        innerHeight: number
    ) {
        // Draw historical data line
        g.append("path")
            .datum(this.diffSeries)
            .attr("fill", "none")
            .attr("stroke", "#00818F")
            .attr("stroke-width", 2)
            .style("stroke-dasharray", "0")
            .attr("d", lineGen);

        // Add status text
        g.append("text")
            .attr("x", innerWidth - 10)
            .attr("y", -10)
            .attr("text-anchor", "end")
            .style("fill", "red")
            .style("font-size", "12px")
            .text("ADF failed: Series non-stationary. OU not applied.");

        // Add tooltip interaction overlay
        g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mousemove", (event) => {
                const mouseX = xScale.invert(d3.pointer(event)[0]);
                const index = bisectDate(this.diffSeries, mouseX);
                const d = this.diffSeries[index];
                if (d) showTooltip(event, d);
            })
            .on("mouseout", hideTooltip);
    }
}
